<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on  无意 </title>
		<link>https://whocanfly.gitee.io/posts/</link>
		<description>Recent content in Posts on  无意 </description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-hans</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Sun, 10 Apr 2022 22:47:27 +0800</lastBuildDate>
		<atom:link href="https://whocanfly.gitee.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Kubernetes服务发现与负载均衡</title>
			<link>https://whocanfly.gitee.io/posts/kubernetes%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link>
			<pubDate>Sun, 10 Apr 2022 22:47:27 +0800</pubDate>
			
			<guid>https://whocanfly.gitee.io/posts/kubernetes%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid>
			<description>什么是服务发现和负载均衡 服务发现 在微服务架构是由一系列职责单一的细粒度服务构成的分布式网状结构，服务之间通过轻量机制进行通信，这时候必然引入</description>
			<content type="html"><![CDATA[<h2 id="什么是服务发现和负载均衡">什么是服务发现和负载均衡</h2>
<h3 id="服务发现">服务发现</h3>
<p>在微服务架构是由一系列职责单一的细粒度服务构成的分布式网状结构，服务之间通过轻量机制进行通信，这时候必然引入一个服务注册发现问题，也就是说服务提供方要注册通告服务地址，服务的调用方要能发现目标服务。本质上就是一种了解集群中是否有进程监听在某个 DUP 或者 TCP 端口的机制，并且通过服务名字就能进行查找和链接，因为在微服务中，一个服务重启后其 <code>endpoint</code> 极有可能发生变化。所以需要有一个<strong>服务注册表</strong>来维护服务名到服务实例列表的映射，并且实时更新。<strong>服务注册表是联系服务提供者和服务消费者的桥梁。</strong></p>
<h3 id="负载均衡">负载均衡</h3>
<p>一般情况下服务提供方都会以多个实例的形式运行，并且使用同一个服务名对外提供服务，那么在服务调用方试图连接服务提供方时，就必须选择一个实例， 可以由客户端选择，也可以由服务端选择，这就是负载均衡，一般情况下服务发现都伴随着负载均衡。负载均衡可以有多种不同的算法实现，常见的有轮询，随机，源地址哈希，加权轮询，加权随机等。</p>
<h2 id="传统微服务架构下的服务发现与负载均衡实现">传统微服务架构下的服务发现与负载均衡实现</h2>
<p>除了服务提供方和调用方，一般还会引入一个<strong>服务中介</strong>来维护服务注册表。</p>
<h3 id="最简单的服务发现机制实现">最简单的服务发现机制实现</h3>
<ol>
<li>服务提供方在服务启动的时候，把服务名和实例更新到服务注册表中，在服务退出的时候删除自身的服务注册信息。</li>
<li>服务调用方在请求服务的时候，按照服务名到服务注册表中获取服务实例列表，然后从列表里挑选一个服务实例，向该实例请求服务。</li>
</ol>
<p>以上就是最简单的服务发现机制实现，这样的实现实际上还存在不少问题</p>
<h3 id="问题">问题</h3>
<ol>
<li>如果服务不是正常停止，而是被强制 <code>kill</code>，那么就没有机会通知服务中介删除自身的服务注册信息，这样服务注册表就多一条无效服务实例的信息；要解决这个问题就需要服务中介具备 TTL 的能力，即为注册的服务实例设置一个过期时间，然后由服务提供方在过期时间内进行<strong>保活</strong>，如果在超过了过期时间，那么服务中介就自动剔除该实例的注册信息，实际上这就是简单的<strong>健康检查</strong>机制</li>
<li>服务调用方如果每次调用都要先查询服务中介获取实例列表，再请求服务，那么效率就太低了，而且对服务中介来说也是请求压力；所以在实现时，通常都会让客户端<strong>缓存服务实例列表</strong>，这样对同名服务的多次请求，便不用重复查询，既减少了延迟又减轻了对服务中介的访问压力。</li>
<li>在过期时间和客户端缓存失效内服务提供方挂了， 服务调用方是无法感知的，所以在这个短暂时间内服务调用方的请求还是会发到无效地址上，这个问题无法从根本上解决，所以客户端需要有容忍机制，比如在出现多次错误之后在一段时间内不再向此实例发送请求</li>
<li>服务提供方的实例列表发生变化之后如何通知服务调用方，一般是通过服务调用方 <strong>watch (监听)<strong>服务中介，当服务调用方通知服务中介更新服务注册表时，服务中介需要具备</strong>主动通知</strong>服务调用方的能力，然后服务调用方就可以更新自己的缓存了</li>
<li>服务调用方如何从多个服务实例中选择一个，即负载均衡算法的实现，常见的有轮询，随机，源地址哈希，加权轮询，加权随机等。</li>
<li>服务中介如果挂了怎么办，一般都是使用<strong>集群</strong>解决这种单点问题</li>
</ol>
<p>综上、要解决这些问题，还需要服务中介具备<strong>强一致性、高可用的服务存储、TTL 、watch、健康检查、集群方案</strong>等能力，常见的开源解决组件有 <code>etcd</code>、<code>zookeeper</code>、<code>consul</code>，本质上<strong>使用分布式一致性数据库</strong>来保存注册表信息，它既解决读写性能问题又提高了系统稳定性和可用性。</p>
<h3 id="负载均衡的作用">负载均衡的作用</h3>
<ul>
<li>解决并发压力，提高应用处理性能，增加吞吐量，加强网络处理能力</li>
<li>提供故障转移，实现高可用</li>
<li>通过增加或减少服务数量，提供伸缩性、可扩展性</li>
<li>安全防护，负载均衡设备上做一些过滤，黑名单等处理</li>
</ul>
<h3 id="负载均衡的分类">负载均衡的分类</h3>
<ol>
<li>
<p>按负载均衡载体划分：</p>
<p>硬件负载均衡： 如 F5、A10 等，功能强大、性能强悍、安全性高，但成本昂贵、扩展性差</p>
<p>软件负载均衡：如 Nginx、Envoy/Istio、 HAProxy、LVS 等，扩展性好、成本低廉，但性能较硬件负载均衡略差</p>
</li>
<li>
<p>按网络通信分类</p>
<ol>
<li>
<p><strong>七层负载均衡</strong>：就是可以根据访问用户的 HTTP 请求头、URL 信息将请求转发到特定的主机</p>
<ul>
<li>
<p><strong>DNS 负载均衡</strong></p>
<p>最早的负载均衡技术， 利用域名解析实现负载均衡*，在 DNS 服务器配置多个 A 记录这些 A 记录对应的服务器构成集群，省掉了负载均衡服务器维护的麻烦，但有缓存 TTL 的问题， 支持的负载均衡算法少，只能用于业务不敏感的系统*</p>
</li>
<li>
<p><strong>HTTP 重定向</strong></p>
<p><em>基于 HTTP 重定向实现负载均衡， 方案简单，但需要客户端发起两次请求，性能差</em></p>
</li>
<li>
<p><strong>反向代理软件</strong></p>
<p><em>在代理服务器上设定好负载均衡规则。然后当收到客户端请求，反向代理服务器拦截指定的域名或 IP 请求，根据负载均衡算法，将请求分发到候选服务器上。支持多种负载均衡算法，可以监控转发服务器状态，如：系统负载、响应时间、是否可用、连接数、流量等，从而动态调整负载均衡的转发策略</em></p>
</li>
</ul>
</li>
<li>
<p><strong>四层负载均衡</strong>：基于 IP 地址和端口进行请求的转发。</p>
<ul>
<li>
<p><strong>IP 负载均衡</strong></p>
<p>IP 负载均衡是在网络层通过修改请求数据包的目的地址进行负载均衡。</p>
<p>IP 负载均衡在内核进程完成数据分发，较反向代理负载均衡有更好的从处理性能。但是，由于所有请求响应都要经过负载均衡服务器，集群的吞吐量受制于负载均衡服务器的带宽。</p>
</li>
<li>
<p><strong>数据链路层负载均衡</strong></p>
<p>数据链路层负载均衡是指在通信协议的数据链路层修改 <code>mac</code> 地址进行负载均衡。代表的开源产品是 LVS，LVS 是基于 Linux 内核中 <code>netfilter</code> 框架实现的负载均衡系统。可以在数据包流经过程中，根据规则设置若干个关卡（hook 函数）来执行相关的操作。</p>
<p>LVS 的工作原理：ipvs(内核态)+ ipvsadm(用户态，负责编写 ipvs 规则)</p>
<ol>
<li>当用户向负载均衡调度器（Director Server）发起请求，调度器将请求发往至内核空间</li>
<li>PREROUTING 链首先会接收到用户请求，判断目标 IP 确定是本机 IP，将数据包发往 INPUT 链</li>
<li>IPVS 是工作在 INPUT 链上的，当用户请求到达 INPUT 时，IPVS 会将用户请求和自己已定义好的集群服务进行比对，如果用户请求的就是定义的集群服务，那么此时 IPVS 会强行修改数据包里的目标 IP 地址及端口，并将新的数据包发 POSTROUTING 链</li>
<li>POSTROUTING 链接收数据包后发现目标 IP 地址刚好是自己的后端服务器，那么此时通过选路，将数据包最终发送给后端的服务器</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="kubernetes-是怎么实现服务发现和负载均衡的">Kubernetes 是怎么实现服务发现和负载均衡的</h2>
<p>Kubernetes 支持两种基本的服务发现模式 —— 环境变量和 DNS。</p>
<p><strong>环境变量</strong></p>
<ul>
<li>当 Pod 运行在 <code>Node</code>上，kubelet 会为每个活跃的 Service 添加一组环境变量并注入 Pod 中</li>
<li>如果要在 Pod 中使用基于环境变量的服务发现方式，必须先创建 Service，再创建调用 Service 的 Pod。否则，Pod 中不会有该 Service 对应的环境变量。</li>
</ul>
<p><strong>DNS</strong></p>
<p>DNS 服务是 Kuberneets 集群的附加组件，例如 CoreDNS， CoreDNS 监听 Kubernetes API 上创建和删除 Service 的事件，并为每一个 Service 创建一条 DNS A 记录。集群中所有的 Pod 都可以使用 DNS 将 ServiceName 解析到 Service 的 IP 地址(Headless 服务解析为 Endpoint 列表，其他服务解析为 ClusterIP)。</p>
<p>同时也支持 DNS SRV 记录，假设 <code>my-service.my-ns</code>Service 有一个 TCP 端口名为 <code>http</code>，则，您可以 <code>nslookup _http._tcp.my-service.my-ns</code>以发现该 Service 的 IP 地址、端口 <code>http</code> 。</p>
<p>对于 <code>ExternalName</code>类型的 Service，只能通过 DNS 的方式进行服务发现。</p>
<p>对于 “Headless” Service 而言：</p>
<ul>
<li>没有 Cluster IP</li>
<li><code>kube-proxy</code> 不处理这类 Service</li>
<li>Kubernetes 不提供负载均衡或代理支持</li>
</ul>
<h3 id="service">Service</h3>
<p>在 Kubernetes 中，可以为 pod 设置标签（Label）进行标记，并通过 Service 对象的 Selector 定义基于 Pod 标签的过滤规则，通过 Ports 定义协议类型和端口映射</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="cp">**apiVersion:</span><span class="w"> </span>v1<span class="w">
</span><span class="w"></span><span class="k">kind</span><span class="p">:</span><span class="w"> </span>Service<span class="w">
</span><span class="w"></span><span class="k">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="k">name</span><span class="p">:</span><span class="w"> </span>my-service<span class="w">
</span><span class="w"></span><span class="k">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="k">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="k">app</span><span class="p">:</span><span class="w"> </span>MyApp<span class="w">
</span><span class="w">  </span><span class="k">ports</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="k">protocol</span><span class="p">:</span><span class="w"> </span>TCP<span class="w">
</span><span class="w">      </span><span class="k">port</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">
</span><span class="w">      </span><span class="k">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">9376</span><span class="cp">**</span><span class="w">
</span></code></pre></div><p>在 Kubernetes 中创建了以上的 Service 对象之后，Kubenetes 中的 kube-controller-manager 会生成用于暴露 Pod 的 Kubernetes 对象，即 Endpoint 对象；运行在每个节点上的 kube-proxy 中会监听到 Service 和 Endpoint 的事件更新，然后生成主机节点的 iptables 或者 ipvs 规则，从而实现负载均衡。</p>
<h3 id="控制器">控制器</h3>
<p>除了 <code>kube-proxy</code> 之外， <code>kube-controller-manager</code> 中有两个控制器监听了 Service 变动的事件，一个是 ServiceController，另一个是 EndpointController，在四种 Service 类型中，ServiceController 只处理 LoadBlancer 类型，其他三种类型由 EndpointController 进行处理，EndpointController 本身不监听 Endpoint 的变化，但是它却同时订阅了 Service 和 Pod 资源的增删事件，并根据当前集群中的对象生成 Endpoint 对象将两者进行关联。</p>
<h3 id="代理">代理</h3>
<p>Kubernetes 集群中的每个节点都运行了一个 <code>kube-proxy</code>，负责为 Service（没有 Selector 的除外）提供虚拟 IP 访问****</p>
<p><strong>代理模式</strong></p>
<p><code>kube-proxy</code> 当前的代理模式有三种：<code>userspace</code>、<code>iptables</code>、<code>ipvs</code>，这三种模式只有 <code>userspace</code>运行在用户空间，<code>iptables</code> 和 <code>ipvs</code> 运行在内核空间能够为 Kubernetes 集群提供更加强大的性能支持，Kubernetes 当前默认使用的是 <code>iptables</code> 代理模式</p>
<p><strong>userspace 代理模式</strong></p>
<ul>
<li><img src="https://s2.loli.net/2022/04/10/vXEcnL9RAkxCJTy.png" alt="image-20220410224950514"></li>
<li><code>kube-proxy</code> 监听 <code>kube-api-server</code>以获得添加和移除 Service / Endpoint 的事件</li>
<li><code>kube-proxy</code> 在其所在的节点（每个节点都有 <code>kube-proxy</code>）上为每一个 Service 打开一个随机端口</li>
<li><code>kube-proxy</code> 安装 iptables 规则，将发送到该 Service 的 ClusterIP（虚拟 IP）/ Port 的请求重定向到该随机端口</li>
<li>任何发送到该随机端口的请求将被代理转发到该 Service 的后端 Pod 上（kube-proxy 从 Endpoint 信息中获得可用 Pod）</li>
<li><code>kube-proxy</code> 在决定将请求转发到后端哪一个 Pod 时，默认使用 <code>round-robin</code>（轮询）算法，并会考虑到 Service 中的 SessionAffinity 的设定</li>
</ul>
<p>此代理模式的唯一优势是如果一个连接被目标服务拒绝，kube-proxy 能够重新尝试连接其他的服务，但是数据包从网卡进入内核空间之后又转发到用户空间，最终还是需要在内核空间处理，所以性能比较差</p>
<p><strong>iptables 代理模式</strong></p>
<ul>
<li><img src="https://s2.loli.net/2022/04/10/gksTPYjAzG1Ii8D.png" alt="image-20220410225023640"></li>
<li><code>kube-proxy</code> 监听 <code>kube-api-server</code> 以获得添加和移除 Service / Endpoint 的事件</li>
<li><code>kube-proxy</code> 在其所在的节点（每个节点都有 <code>kube-proxy</code>）上为每一个 Service 安装 <code>iptables</code>规则</li>
<li><code>iptables</code> 将发送到 Service 的 ClusterIP / Port 的请求重定向到 Service 的后端 Pod 上
<ul>
<li>对于 Service 中的每一个 Endpoint，<code>kube-proxy</code> 安装一条 iptable 规则</li>
<li>默认情况下，<code>kube-proxy</code> 随机选择一个 Service 的后端 Pod</li>
</ul>
</li>
</ul>
<p>为了避免 <code>kube-proxy</code> 将请求转发到已经存在问题的 Pod 上， 可以配置 Pod 就绪检查（<code>readiness probe</code>）确保后端 Pod 正常工作，此时，在 <code>iptables</code> 模式下 <code>kube-proxy</code> 将只使用健康的后端 Pod。</p>
<p><strong>iptables 原理</strong></p>
<p>iptables 是基于 Netfilter 框架实现的，Netfilter 实现了 5 个不同的 Hook 点，每到达一个 Hook 点时，都会调用内核模块定义的处理函数，具体调用哪个函数取决于数据包的流向，进站流量和出站流量触发的 Hook 点不同。</p>
<p>针对 Netfilter 的五个 Hook 点，iptables 定义了五个规则链（iptables Chain）</p>
<ul>
<li>PREROUTING：对数据包做路由决策前应用此链中的规则</li>
<li>INPUT：路由决策之后进入本机的数据包应用此规则链中的策略</li>
<li>FORWARD：转发数据包时应用此规则链中的策略</li>
<li>OUTPUT：本机的数据包外出时应用此规则链中的策略</li>
<li>POSTROUTING：对数据包做路由决策后应用此链中的规则</li>
</ul>
<p>根据处理数据包的目的，规则又被划分不同的表</p>
<ul>
<li>fileter：根据数据包 IP、端口等信息来决定是接受还是丢弃该数据包， 多用于防火墙规则的配置</li>
<li>nat：用于实现网络地址的转换规则</li>
<li>managle：主要用来修改数据包的服务类型，生存周期，为数据包设置标记，实现流量整形、策略路由等</li>
<li>raw：主要用来决定是否对数据包进行状态跟踪</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/10/vz4ulfGSrqcVgb3.png" alt="image-20220410225109166"></p>
<p>当我们使用 <code>iptables</code> 的方式启动节点上的代理时，所有的流量都会先经过 <code>PREROUTING</code>或者 <code>OUTPUT</code> 链，随后进入 Kubernetes 自定义的链入口 KUBE-SERVICES、单个 Service 对应的链 <code>KUBE-SVC-XXXX</code>以及每个 Pod 对应的链 <code>KUBE-SEP-XXXX</code>，经过这些链的处理，最终才能够访问当一个服务的真实 Pod IP 地址。</p>
<p>如果是本机 的 Pod 发起请求，请求在经过容器网络 Namespace 转发至主机网络的 Namespace 后，依次交由 OUTPUT 链、KUBE-SERVICES 链进行处理，根据 KUBE-SERVICES 链的匹配规则检查包头，若匹配到目标 ClusterIP, 则该请求会被转发到 KUBE-SVC-XXX  链进行处理，最终随机匹配到 KUBE-SEP-XXX 的 dnat 规则，然后经过路由决策进入 POSTROUTING 链，所有经过 POSTROUTING 链的数据包都要被 KUBE-POSTROUTING 链处理，而 KUBE-POSTROUTING 链只有一个作用，那就是执行 IP 伪装，将数据包的源地址改为本机 IP 。</p>
<p>如果数据包是从外部通过主机IP + 服务 nodePort 进入的，那么数据包先流经网卡，在进入 Linux 内核网络协议栈，首先触发的是 PREROUTING 链上的规则，KUBE-SERVICES 依次匹配所有 ClusterIP，由于数据包目的地址是主机 IP，所有任何一条 ClusterIP 规则都匹配不到，交由最后一条跳转到 KUBE-NODEPORTS 链进行处理，匹配到 nodePort 规则之后 ，数据包先后流经 KUBE-SVC 链、KUBE-SEP 链处理， 最终随机匹配到 KUBE-SEP-XXX 的 dnat 规则。</p>
<p><code>iptables-save -t nat</code></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="m">105</span> -A PREROUTING -m comment --comment <span class="s2">&#34;kubernetes service portals&#34;</span> -j KUBE-SERVICES
<span class="m">108</span> -A OUTPUT -m comment --comment <span class="s2">&#34;kubernetes service portals&#34;</span> -j KUBE-SERVICES
<span class="m">111</span> -A POSTROUTING -m comment --comment <span class="s2">&#34;kubernetes postrouting rules&#34;</span> -j KUBE-POSTROUTING
<span class="m">134</span> -A KUBE-POSTROUTING -m mark ! --mark 0x4000/0x4000 -j RETURN
<span class="m">135</span> -A KUBE-POSTROUTING -j MARK --set-xmark 0x4000/0x0
<span class="m">136</span> -A KUBE-POSTROUTING -m comment --comment <span class="s2">&#34;kubernetes service traffic requiring SNAT&#34;</span> -j MASQUERADE --random-fully

<span class="m">240</span> -A KUBE-SERVICES -d 11.254.6.23/32 -p tcp -m comment --comment <span class="s2">&#34;default/test-nodeport:test-nodeport cluster IP&#34;</span> -m tcp --dport <span class="m">7443</span> -j KUBE-SVC-AODHVUMZDDCZ4Z2P
<span class="m">303</span> -A KUBE-SERVICES -m comment --comment <span class="s2">&#34;kubernetes service nodeports; NOTE: this must be the last rule in this chain&#34;</span> -m addrtype --dst-type LOCAL -j KUBE-NODEPORTS
<span class="m">123</span> -A KUBE-NODEPORTS -p tcp -m comment --comment <span class="s2">&#34;default/test-nodeport:test-nodeport&#34;</span> -m tcp --dport <span class="m">47565</span> -j KUBE-SVC-AODHVUMZDDCZ4Z2P

<span class="m">310</span> -A KUBE-SVC-AODHVUMZDDCZ4Z2P -m comment --comment <span class="s2">&#34;default/test-nodeport:test-nodeport&#34;</span> -j KUBE-SEP-PJWVY5FQJPODECLS
<span class="m">206</span> -A KUBE-SEP-PJWVY5FQJPODECLS -p tcp -m comment --comment <span class="s2">&#34;default/test-nodeport:test-nodeport&#34;</span> -m tcp -j DNAT --to-destination 172.244.166.141:6443
</code></pre></div><p><strong>iptables 缺点：</strong></p>
<ul>
<li>每次对规则进行匹配时都会遍历 <code>iptables</code>中的所有 Service 链</li>
<li>无法进行增量式更新</li>
</ul>
<p>大规模集群中使用 <code>iptables</code> 作为代理模式存在严重的性能问题，是完全不可用的。</p>
<p><strong>IPVS 代理模式</strong></p>
<p><img src="https://s2.loli.net/2022/04/10/vIX23AqHhgZDoy1.png" alt="image-20220410225138842"></p>
<ul>
<li><code>kube-proxy</code> 监听 <code>kube-api-server</code> 以获得添加和移除 Service / Endpoint 的事件</li>
<li>kube-proxy 根据监听到的事件，调用 <code>netlink</code> 接口，创建 <strong>IPVS</strong> 规则；并且将 Service/Endpoint 的变化同步到 <strong>IPVS</strong> 规则中</li>
<li>当访问一个 Service 时，<strong>IPVS</strong> 将请求重定向到后端 Pod</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/10/vz3s4mxSaHMqGP7.png" alt="image-20220410225213489"></p>
<p><strong>IPVS 优点</strong></p>
<p>IPVS 就是用于解决在大量 Service 时，<code>iptables</code> 规则同步变得不可用的性能问题。与 <code>iptables</code> 比较像的是，<code>ipvs</code> 的实现虽然也基于 <code>netfilter</code> 的钩子函数，但是它却使用哈希表作为底层的数据结构并且工作在内核态，这也就是说 IPVS 在重定向流量和同步代理规则有着更好的性能。</p>
<p><strong>IPVS 提供更多的负载均衡选项：</strong></p>
<ul>
<li><code>rr</code>：轮替（Round-Robin）</li>
<li><code>lc</code>：最少链接（Least Connection），即打开链接数量最少者优先</li>
<li><code>dh</code>：目标地址哈希（Destination Hashing）</li>
<li><code>sh</code>：源地址哈希（Source Hashing）</li>
<li><code>sed</code>：最短预期延迟（Shortest Expected Delay）</li>
<li><code>nq</code>：从不排队（Never Queue）</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="https://bbs.huaweicloud.com/blogs/193876">一文讲清服务发现和负载均衡</a></li>
<li><a href="http://blog.itpub.net/69912579/viewspace-2775774">深入浅出负载均衡</a></li>
<li><a href="https://www.cnblogs.com/liwei0526vip/p/6370103.html">使用 LVS 实现负载均衡原理及安装配置详解</a></li>
<li><a href="https://draveness.me/kubernetes-service/">详解 Kubernetes Service 的实现原理</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Kubernetes初探</title>
			<link>https://whocanfly.gitee.io/posts/kubernetes%E5%88%9D%E6%8E%A2/</link>
			<pubDate>Sun, 10 Apr 2022 22:27:27 +0800</pubDate>
			
			<guid>https://whocanfly.gitee.io/posts/kubernetes%E5%88%9D%E6%8E%A2/</guid>
			<description>Kubernetes 的设计理念 声明式 API 使用者直接描述期望状态，而不必在意过程，这样能够简化需要的代码，减少开发人员的工作；而命令式 API 更强调过程，它要求使用者提</description>
			<content type="html"><![CDATA[<h2 id="kubernetes-的设计理念">Kubernetes 的设计理念</h2>
<p><strong>声明式 API</strong></p>
<p>使用者直接描述期望状态，而不必在意过程，这样能够简化需要的代码，减少开发人员的工作；而命令式 API 更强调过程，它要求使用者提供每一个过程指令、虽然在配置上比较灵活，但是带来了更多的工作，与更在乎结果和状态的声明式 API 截然相反。</p>
<p><strong>显示接口</strong></p>
<p>Kubernetes 不存在内部的私有接口，所有的接口都是显示定义的，组件之间通信使用的接口对于使用者来说都是显式的，我们都可以直接调用。</p>
<p><strong>无侵入性</strong></p>
<p>每一个应用或者服务一旦被打包成了镜像就可以直接在 Kubernetes 中无缝使用，不需要修改应用程序中的任何代码。</p>
<p><strong>可移植性</strong></p>
<p>Kubernetes 使用 StatefulSet 能够很好的支持有状态服务，同时引入 PV （PersistentVolume）和 PVC（PersistentVolumeClaim） 概念屏蔽了底层存储的差异，与无侵入性的特点共同支持了可移植性。</p>
<h2 id="kuberbetes-的组件">Kuberbetes 的组件</h2>
<p><strong>Kube-ApiServer</strong></p>
<p>整个 Kubernetes 集群的 “灵魂”，是信息的汇聚中枢，提供了所有内部和外部的 API 请求操作的唯一入口。同时也负责整个集群的认证、授权、访问控制、服务发现等能力。用户可以通过命令行工具 <code>kubectl</code> 和 <code>apiserver</code> 进行交互，从而实现对集群中进行各种资源的增删改查等操作。<code>apiserver</code> 跟 BorgMaster 非常类似，会将所有的改动持久到 <code>etcd</code> 中，同时也保存着一份内存拷贝。</p>
<p><strong>Kube-Controller-Manager</strong></p>
<p>负责维护整个 Kubernetes 集群的状态，比如多副本创建、滚动更新等。<code>kube-controller-manager</code> 并不是一个单一组件，内部包含了一组资源控制器，在启动的时候，会通过 <code>goroutine</code>拉起多个资源控制器。这些控制器的逻辑仅依赖于当前状态，因为在分布式系统中没办法保证全局状态的同步。同时在实现的时候避免使用过于复杂的状态机，因此每个控制器仅仅对自己对应的资源对象做操作。而且控制器做了很多容错处理，比如增加 <code>retry</code> 机制等。</p>
<p><img src="https://s2.loli.net/2022/04/10/7oEiU1BIc3XVjA8.png" alt="image-20220410222102033"></p>
<p><strong>Kube-Scheduler</strong></p>
<p>简单来说就是负责监听未调度的 Pod，按照预定的调度策略绑定到满足条件的节点上。需要考虑优先级、资源高效利用、高性能、QoS、affinity 和 anti-affinity、数据本地化、内部负载干扰等。</p>
<p>总的来说，调度的过程主要分为两个大步骤。</p>
<ul>
<li>过滤一些不满足条件的节点，这个过程也称为 Predicate。</li>
<li>调度器会对这些合适的节点进行打分排序，从中选择一个最优的节点，这个过程也称为 Priority。</li>
</ul>
<p><strong>Predicate 策略</strong></p>
<ul>
<li>PodFitsHostPort: 检查是否有 Host Port 冲突</li>
<li>PodFitsPort：同 PodFitsHostPort</li>
<li>PodFitsResources：检查 Node 的资源是否充足，包括允许的 Pod 数量、CPU、内存、GPU 个数以及其他的 OpaqueIntResources</li>
<li>HostName: 检查 pod.Spec.NodeName 是否与候选节点一致</li>
<li>MatchNodeSelector：检查 pod.Spec.NodeSelector 是否与候选节点一致</li>
<li>NoVolumeZoneConflict：检查 <code>volume zone</code> 是否冲突</li>
<li>MatchInterPodAffinity：检查是否匹配 pod 的亲和性要求</li>
<li>NoDiskConflict：检查是否存在 Volume 冲突，仅限于 GCE PD、AWS EBS、Ceph RBD 及 iSCSI</li>
<li>PodToleratesNodeTaints：检查 Pod 是否容忍 Node Taints</li>
<li>CheckNodeMemoryPressure：检查 Pod 是否可以调度到 MemoryPressure 的节点上</li>
<li>CheckNodeDiskPressure：检查 Pod 是否可以调度到 DiskPressure 的节点上</li>
<li>NoVolumeNodeConflict： 检查节点是否满足 Pod 所引用的 <code>volume</code> 的条件</li>
<li>&hellip;</li>
</ul>
<p><strong>Priorities 策略</strong></p>
<ul>
<li>SelectorSpreadPriority:：优先减少节点上属于同一个 Service 的 pod 数量</li>
<li>InterPodAffinityPriority：优先将 Pod 调度到相同的拓扑上（如同一个节点、Rack、Zone 等）</li>
<li>LeastRequestedPriority：优先调度到请求资源少的节点上</li>
<li>BalancedResourceAllocation：优先平衡各节点的资源使用</li>
<li>NodePreferAvoidPodsPriority： <a href="http://alpha.kubernetes.io/preferAviodPods">alpha.kubernetes.io/preferAviodPods</a> 字段判断，权重为 1000，避免其他优先级策略影响</li>
<li>NodeAffinityPriority：优先调度到匹配 NodeAffinity 的节点上</li>
<li>TaintTolerationPriority：优先调度到匹配 TaintToleration 的节点上</li>
<li>ServiceSpreadingPriority：尽量将同一个 Service 的 Pod 分布到不同的节点上, 已经被SelectorSpreadPriority 替代（默认未使用）</li>
<li>EqualPriority：将所有节点优先级设置为 1（默认未使用）</li>
<li>ImageLocalityPriority：尽量将使用大镜像的容器调度到已经下拉了该镜像的节点上（默认未使用）</li>
<li>MostRequestedPriority： 尽量调度到已经使用过的 Node 上，特别适用于 cluster-autoscaler （默认未使用）</li>
</ul>
<p><strong>CRI（container-runtime-interface）</strong></p>
<p>容器运行时主要负责容器的镜像管理以及容器创建及运行。只要符合 CRI 的运行时就可以在 <code>kubernetes</code> 中运行</p>
<p><strong>Kubelet</strong></p>
<ul>
<li>接收并执行 <code>master</code>发来的指令</li>
<li>负责维护 Pod 的生命周期，比如创建和删除 Pod 对应的容器。同时也负责存储和网络的管理。一般会配合 CSI、CNI 插件一起工作。</li>
<li>每个 <code>kubelet</code> 进程会在 API Server 上注册节点自身信息，定期向 <code>master</code> 节点汇报节点的资源使用情况，并通过 <code>cAdvisor</code> 监控节点和容器的资源</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/10/fw3UpovrSLWl2Xc.png" alt="kubelet"></p>
<p><img src="https://s2.loli.net/2022/04/10/ekQztXyx5vOJHWN.png" alt="image-20220410222246015"></p>
<p><strong>Kube-Proxy</strong></p>
<p>主要负责 <code>kubernetes</code> 内部的服务通信，在主机上维护网络规则并提供转发及负载均衡能力。</p>
<p><strong>其他非必须组件</strong></p>
<p>CoreDNS 负责为整个集群提供 DNS 服务；</p>
<p>Ingress Controller 为服务提供外网接入能力；</p>
<p>Dashboard 提供 GUI 可视化界面；</p>
<p>Fluentd + Elasticsearch 为集群提供日志采集、存储与查询等能力。</p>
<p>Federation：提供跨可用区的集群；</p>
<h2 id="master-和-node-的交互方式">Master 和 Node 的交互方式</h2>
<p>Kubernetes 中所有的状态都是采用 <code>node</code> 向 <code>master</code>上报的方式实现的。<code>apiserver</code> 不会主动跟 <code>kubelet</code> 建立连接请求，所有容器状态汇报都是由 <code>kubelet</code> 主动向 <code>apiserver</code> 发起的。一旦新增的 <code>node</code> 被 <code>apiserver</code> 纳管进来后，<code>kubelet</code> 进程就会定时向 <code>apiserver</code> 汇报 “心跳”，即汇报自身的状态，包括自身健康状态、负载数据统计等。当一段时间内心跳包没有更新，那么此时 <code>kube-controller-manager</code> 就会将其标记为 NodeLost（失联）。</p>
<h2 id="pod">Pod</h2>
<p>pod 是 Kubernetes 中原子化的部署单元，是 Kubernetes 中不可变的基础设施， 它可以包含一个或多个容器，而且容器之间可以共享网络、存储资源。在日常使用过程中，也应该尽量避免在一个 Pod 内运行多个不相关的容器</p>
<p><strong>为什么 Kubernetes 不直接管理容器，而用 pod 来管理呢？</strong></p>
<p>因为使用一个新的逻辑对象 Pod 来管理容器，可以在不重载容器信息的基础上，添加更多的属性，而且也方便跟容器运行时进行解耦，兼容度高；而且这些容器在通过 Kubernetes 创建之后就能共享网络和存储，可以构建比较复杂的服务拓扑和依赖关系</p>
<p><strong>为什么要允许一个 pod 内可以包含多个容器？</strong></p>
<p>用一个 pod 管理多个容器，既能够保持容器之间的隔离性，还能保证相关容器的环境一致性。使用粒度更小的容器，不仅可以使应用间的依赖解耦，还便于使用不同技术栈进行开发，同时还可以方便各个开发团队复用，减少重复造轮子。</p>
<p><strong>pod 的状态</strong></p>
<ol>
<li>Pending:
<ol>
<li>pod 还未被调度</li>
<li>pod 内的容器镜像在待运行的节点上不存在，需要从镜像中心拉取</li>
</ol>
</li>
<li>Running: pod 内的所有容器均被创建出来了，且至少有一个容器为在运 Succeeded: 表示 Pod 内的所有容器均成功运行结束，即正常退出，退出码为 0；</li>
<li>Failed: pod 内的所有容器均运行终止，且至少有一个容器终止失败了，一般这种情况，都是由于容器运行异常退出，或者被系统终止掉了；</li>
<li>Unknown: 一般是由于 Node 失联导致的 Pod 状态无法获取到</li>
</ol>
<p><strong>pod 的重启策略</strong></p>
<p>Kubernetes 中定义了如下三种重启策略，可以通过 spec.restartPolicy 字段在 Pod 定义中进行设置。</p>
<ul>
<li>always: 表示一直重启，这也是默认的重启策略。Kubelet 会定期查询容器的状态，一旦某个容器处于退出状态，就对其执行重启操作；</li>
<li>onFailure: 表示只有在容器异常退出，即退出码不为 0 时，才会对其进行重启操作；</li>
<li>never: 表示从不重启；</li>
</ul>
<p><strong>容器生命周期内的 hook</strong></p>
<p>kubernetes 中目前有以下两种 hook：</p>
<ul>
<li>PostStart： 可以在容器启动之后就执行。但需要注意的是，此 hook 和容器里的 ENTRYPOINT 命令的执行顺序是不确定的。</li>
<li>PreStop： 则在容器被终止之前被执行，是一种阻塞式的方式。执行完成后，Kubelet 才真正开始销毁容器。
init 容器</li>
</ul>
<p>一种特殊容器，通常用来做一些初始化工作，比如环境检测、OSS 文件下载、工具安装，等等。</p>
<p>一个 Pod 中允许有一个或多个 init 容器。init 容器和其他一般的容器非常像，其与众不同的特点主要有：</p>
<ul>
<li>总是运行到完成，可以理解为一次性的任务，不可以运行常驻型任务，因为会 block 应用容器的启动运行；</li>
<li>顺序启动执行，下一个的 init 容器都必须在上一个运行成功后才可以启动；</li>
<li>禁止使用 readiness/liveness 探针，可以使用 Pod 定义的 activeDeadlineSeconds，这其中包含了 Init Container 的启动时间；</li>
<li>禁止使用 lifecycle hook。</li>
</ul>
<p><strong>Pod 的生命周期</strong></p>
<p>Create –&gt; Probe –&gt; Running –&gt; Shutdown –&gt; Restart
.1 Pod 的创建流程</p>
<ol>
<li>计算 Pod 中沙盒和容器的变更</li>
<li>如果 Pod 有变化， 强制停止 Pod 对 强制停止所有不应该运行的容器</li>
<li>如果有必要为 Pod 创建新的沙盒</li>
<li>创建 Pod 规格中指定的 init 容器</li>
<li>依次创建 Pod 规格中指定的常规容器</li>
</ol>
<p><strong>Pod 健康检查</strong>
Kubernetes 中提供了一系列的健康检查，可以定制调用，来帮助解决类似的问题，我们称之为 Probe（探针）</p>
<ul>
<li>livenessProbe: 存活探针，可以用来探测容器是否真的在 “运行”，如果检测失败的话，这个时候 kubelet 就会停掉该容器，容器的后续操作会受到其重启策略的影响。</li>
<li>readinessProbe：就绪探针，常常用于指示容器是否可以对外提供正常的服务请求</li>
<li>startupProbe：启动探针，可以用于判断容器是否已经启动好，我们可以通过参数，保证有足够长的时间来应对 “超长” 的启动时间。 如果检测失败的话，同 livenessProbe 的操作。这个 Probe 是在 1.16 版本才加入进来的，到 1.18 版本变为 beta。也就是说如果 Kubernetes 版本小于 1.18 的话，你需要在 kube-apiserver 的启动参数中，显式地在 feature gate 中开启这个功能。</li>
</ul>
<p><strong>探针的三种检测方式</strong></p>
<ul>
<li>ExecAction: 可以在容器内执行 shell 脚本，当返回码为 9 时，探测结果为成功</li>
<li>HTTPGetAction: 方便对指定的端口和 IP 地址执行 HTTP Get 操作，当返回码为 200~ 400 之间时，探测结果视为成功</li>
<li>TCPSocketAction: 可以对指定端口进行 TCP 检查，当端口可达时，探测结果为成功
的删除</li>
</ul>
<p>停止运行容器的大致流程，先从 Pod 的规格中计算出当前优雅停止的超时时间，然后运行钩子方法和内部的生命周期方法，最后将容器停止并清除引用</p>
<h2 id="service">Service</h2>
<p>Kubernetes 中用于实现服务发现和负载均衡，与 Deployment、StatefulSet 一样通过标签选择器来管理 Pod。</p>
<p><strong>Service 一共有四种类型：</strong></p>
<ol>
<li>ClusterIP: 集群 IP, 也叫虚拟 IP, 通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。 这也是默认的 <code>ServiceType</code>。</li>
<li>NodePort：通过每个节点上的 IP 和静态端口（<code>NodePort</code>）暴露服务。 <code>NodePort</code> 服务会路由到自动创建的 <code>ClusterIP</code> 服务。 通过请求 <code>&lt;节点 IP&gt;:&lt;节点端口&gt;</code>，你可以从集群的外部访问一个 <code>NodePort LoadBalancer ：使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 </code>NodePort<code>服务和</code>ClusterIP` 服务上。</li>
<li>ExternalName：常用于访问非运行在 kubernetes 中的服务，通过 ExternalName 类型的 Service便于后续迁移</li>
</ol>
<p><strong>集群内访问 Service</strong></p>
<p>一般来说，在 Kubernetes 集群内，我们有两种方式可以访问到一个 Service。</p>
<ol>
<li>如果该 Service 有 ClusterIP，我们就可以直接用这个虚拟 IP 去访问。</li>
</ol>
<p>当然我们也可以使用该 Service 的域名，依赖于集群内部的 DNS 即可访问。相同 <code>namespace</code> 下的 <code>pod</code> 可以直接使用 <code>serviceName</code> ，如果是不同 <code>namespace</code> 下的 pod 则需要加上该 Service 所在的 <code>namespace</code> 名，即 <code>serviceName.namespace</code>。</p>
<p>如果在某个<code>namespace</code> 下，Service 先于 Pod 创建出来，那么 kubelet 在创建 Pod 的时候，会自动把这些 <code>namespace</code> 相同的 Service 访问信息当作环境变量注入 Pod 中，即 {SVCNAME}_SERVICE_HOST 和 {SVCNAME}_SERVICE_PORT。这里 SVCNAME 对应是各个 Service 的大写名称，名字中的横线会被自动转换成下划线。</p>
<p><strong>Headless Service</strong></p>
<p>所谓 Headless Service 其实是 ClusterIP 的一种， 即 ClusterIP 为 None，则不会分配给 Service 分配IP</p>
<ol>
<li>用户可以自己选择要连接哪个 Pod，通过查询 Service 的 DNS 记录来获取后端真实负载的 IP 地址，自主选择要连接哪个 IP；</li>
<li>可用于部署有状态服务。每个 StatefulSet 管理的 Pod 都有一个单独的 DNS 记录，且域名保持不变，即 <code>&lt;PodName&gt;.&lt;ServiceName&gt;.&lt;NamespaceName&gt;.svc.cluster.local</code>。这样 Statefulset 中的各个 Pod 就可以直接通过 Pod 名字解决相互间身份以及访问问题。</li>
</ol>
<p><strong>注意</strong></p>
<p>没有设置 selector 的 service 不会自动创建 endpoint，用户可以自行创建 endpoint，一般用于指向集群外的 IP</p>
<h2 id="kubernetes-网络模型">Kubernetes 网络模型</h2>
<p><strong>pod 内容器之间的网络通信</strong></p>
<p><code>kubernetes</code> 会为每一个 <code>pod</code> 创建独立的网络命名空间，<code>pod</code> 内的容器共享一个网络命名空间，这些容器之间可以通过 <code>localhost</code> 直接访问彼此的端口。</p>
<p><strong>pod 之间的网络通信</strong></p>
<p>需满足三个条件：</p>
<ul>
<li>pod IP 地址唯一</li>
<li>pod 发出的数据包不进行 NAT</li>
<li>需要知道 pod IP 和所在 Node IP 之间的映射关系</li>
</ul>
<p><strong>pod 到 service 之间的网络通信</strong></p>
<p>当我们创建一个 Service 时，Kubernetes 会为这个服务分配一个虚拟 IP。我们通过这个虚拟 IP 访问服务时，会由 iptables 负责转发。iptables 的规则由 Kube-Proxy 负责维护。</p>
<p>Kube-Proxy 在每个节点上都运行，并监听 Kube-APIServer 中 Service 与 Endpoints 的变化，来更新本地的 iptables 规则，实现其主要功能，包括为新创建的 Service 打开一个本地代理对象，接收请求针对发生变化的 Service 列表，kube-proxy 会逐个处理，处理流程如下：</p>
<ol>
<li>对已经删除的 Service 进行清理，删除不需要的 iptables 规则；</li>
<li>如果一个新的 Service 没设置 ClusterIP，则直接跳过，不做任 获取该 Service 的所有端口定义列表，并逐个读取 Endpoints 里各个示例的 IP 地址，生成或更新对应的 iptables 规则。</li>
<li></li>
</ol>
<p><strong>集群外部与内部组件之间的网络通信</strong></p>
<p>Ingress 可以将集群内服务的 HTTP 和 HTTPS 暴露出来，以方便从集群外部访问。流量路由 Ingress 资源上定义的规则控制。</p>
<h2 id="replicacontroller">ReplicaController</h2>
<p>ReplicaController 来做 Pod 的副本控制，即确保该服务的 Pod 数量维持在特定的数量，如果副本数少于预定的值，则创建新的 Pod。如果副本数大于预定的值，就删除多余的副本。</p>
<h2 id="replicaset">ReplicaSet</h2>
<p>ReplicaSet（可简写为 rs） 用来替代 ReplicaController，虽然 ReplicaController 目前依然可以使用，但是社区已经不推荐继续使用了。这两者的功能和目的完全相同，但是 ReplicaSet 具备更强大的基于集合的标签选择器，这样你可以通过一组值来进行标签匹配选择。目前支持三种操作符：<code>in</code>、<code>notin</code> 和 <code>exists</code>。</p>
<h2 id="deployment">Deployment</h2>
<p>Deployment 是一种比 ReplicatonSet 更加高级的资源对象，通过 Deployment 我们可以管理多个 <code>label</code> 各不相同的 ReplicationSet，每个 ReplicaSet 负责保证对应数目的 Pod 在运行。我们就不需要再关心和操作 ReplicaSet 和 Pod 了。</p>
<p><img src="https://s2.loli.net/2022/04/10/r1DjxEw89KkBpFe.png" alt="image-20210606163943489.png"></p>
<h2 id="statefulset">StatefulSet</h2>
<p>与以上的资源对象对比， StatefulSet 最大的不同就是<strong>有状态</strong>，在部署一个 StatefulSet 的时候，有个前置依赖对象，即 Service（服务）</p>
<p>通过 <code>spec.serviceName</code> 这个字段，保证了 StatefulSet 关联的 Pod 可以有稳定的网络身份标识，即 Pod 的序号、主机名、DNS 记录名称等。</p>
<p>StatefulSet 通过 PersistentVolumeClaim（PVC）可以保证 Pod 的存储卷之间一一对应的绑定关系。同时，删除 StatefulSet 关联的 Pod 时，不会删除其关联的 PVC。</p>
<p><strong>StatefulSet 的特点：</strong></p>
<ul>
<li>对于一个拥有 N 个副本的 StatefulSet 来说， Pod 在部署时按照 {0 …… N-1} 的序号顺序创建的，而删除的时候按照逆序逐个删除，</li>
<li>StatefulSet 创建出来的 Pod 都具有固定的、且确切的主机名</li>
<li>支持持久化存储，而且最好能够跟实例一一绑定；</li>
<li>在进行滚动升级的时候，也会按照一定顺序。</li>
</ul>
<h2 id="daemonset">DaemonSet</h2>
<p>可以在集群内的每个节点上（或者指定的一堆节点上）都只运行一个副本，即 Pod 和 Node 是一一对应的关系。当集群新增或下线节点时，对应的 Pod 会自动新建和删除</p>
<h2 id="configmap-和-secret">ConfigMap 和 Secret</h2>
<p>ConfigMap 和 Secret 是 Kubernetes 常用的保存配置数据的对象，其中 Secret 会将存储的配置数据用<code>base64</code> 加密，可以根据需要选择合适的对象存储数据。通过 Volume 方式挂载到 Pod 内的，kubelet 都会定期进行更新。但是通过环境变量注入到容器中，这样无法感知到 ConfigMap 或 Secret 的内容更新。</p>
<h2 id="pv-和-pvc">PV 和 PVC</h2>
<p>为了将计算和存储进行分离，Kubernetes 中引入了一个专门的对象 Persistent Volume（简称 PV）， 可以使用不同的控制器来分别管理。同时通过 PV，我们也可以和 Pod 自身的生命周期进行解耦。一个 PV 可以被几个 Pod 同时使用，即使 Pod 被删除后，PV 这个对象依然存在，其他新的 Pod 依然可以复用。为了更好地描述这种关联绑定关系，易于使用，并且屏蔽更多用户并不关心的细节参数（比如 PV 由谁提供、创建在哪个 zone/region、怎么去访问到，等等），我们通过一个抽象对象 Persistent Volume Claim（PVC）来使用 PV。</p>
<p>我们可以把 PV 理解成是对实际的物理存储资源描述，PVC 是便于使用的抽象 API。在 Kubernetes 中，我们都是在 Pod 中通过 PVC 的方式来使用 PV 的</p>
<p><strong>创建 PV 的方式有两种：</strong></p>
<ol>
<li>
<p>静态 PV:</p>
<p>需要提前创建好，无法做到按需创建，根据相同的 StorageClassName 值绑定 PV 和 PVC, 如果没指定 StorageClass 且开启了 defaultStorageClass 的 adminssion plugin， 则为 PVC 添加一个默认 StorageClass，否则 StorageClassName 为 “” 。 使用过程中，经常会遇到由于资源大小不匹配，规格不对等，造成 PVC 无法绑定 PV 的情况。同时还会造成资源浪费，比如一个只需要 1G 空间的 Pod，绑定了 10G 的 PV。</p>
</li>
<li>
<p>动态 PV：</p>
<p>创建动态 PV，需要用 StorageClass 这个对象来描述。当用户创建好 Pod 以后，指定了 PVC，这个时候 Kubernetes 就会根据 StorageClass 中定义的 Provisioner 来调用对应的 plugin 来创建 PV。PV 创建成功后，跟 PVC 进行绑定，挂载到 Pod 中使用。</p>
</li>
</ol>
<h2 id="priorityclass">PriorityClass</h2>
<p>PriorityClass 通过给 Pod 设置高优先级，让其比其他 Pod 显得更为重要，通过这种 “插队” 的方式优先获得调度器的调度。这个对象是个集群级别的定义，并不属于任何 <code>namespace</code>，可以被全局使用，即各个 <code>namespace</code> 中创建的 Pod 都能使用 PriorityClass。我们在定义这样一个 PriorityClass 对象的时候，名字不可以包含 <code>system-</code>这个前缀。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">apiVersion</span><span class="p">:</span><span class="w"> </span>scheduling.k8s.io/v1<span class="w">
</span><span class="w"></span><span class="k">kind</span><span class="p">:</span><span class="w"> </span>PriorityClass<span class="w">
</span><span class="w"></span><span class="k">metadata</span><span class="p">:</span><span class="w">  
</span><span class="w">  </span><span class="k">name</span><span class="p">:</span><span class="w"> </span>high-priority<span class="w">
</span><span class="w">  </span><span class="k">value</span><span class="p">:</span><span class="w"> </span><span class="m">1000000</span><span class="w">
</span><span class="w">  </span><span class="k">globalDefault</span><span class="p">:</span><span class="w"> 
</span><span class="w">  </span><span class="k">falsedescription</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;This priority class should be used for XYZ service pods only.&#34;</span><span class="w">
</span></code></pre></div><h2 id="namespace">Namespace</h2>
<p>命名空间为 Kubernetes 集群提供虚拟的隔离作用， Kubernetes 集群初始有两个名字空间，分别是默认名字空间 default 和系统名字空间 kube-system，除此以外，管理员可以创建新的名字空间满足需要。</p>
<h2 id="用户账户user-account-服务帐户service-account">用户账户（User Account）&amp; 服务帐户（Service Account）</h2>
<p>顾名思义，用户帐户为人提供账户标识，而服务账户为计算机进程和 Kubernetes 集群中运行的 Pod 提供账户标识。用户帐户和服务帐户的一个区别是作用范围；用户帐户对应的是人的身份，人的身份与服务的 Namespace 无关，所以用户账户是跨 Namespace 的；而服务帐户对应的是一个运行中程序的身份，与特定 Namespace 是相关的。</p>
<h2 id="rbac-访问授权">RBAC 访问授权</h2>
<p>Kubernetes alpha 版的基于角色的访问控制（Role-based Access Control，RBAC）的授权模式。相对于基于属性的访问控制（Attribute-based Access Control，ABAC），RBAC 主要是引入了角色（Role）和角色绑定（RoleBinding）的抽象概念。</p>
<p>在 ABAC 中， Kubernetes 集群中的访问策略只能跟用户直接关联；而在 RBAC 中，访问策略可以跟某个角色关联，具体的用户在跟一个或多个角色相关联。显然，RBAC 像其他新功能一样，每次引入新功能，都会引入新的 API 对象，从而引入新的概念抽象，而这一新的概念抽象一定会使集群服务管理和使用更容易扩展和重用。</p>
<h2 id="api-设计原则">API 设计原则</h2>
<ul>
<li>低层 API 根据高层 API 的控制需要设计</li>
<li>尽量避免简单封装，不要有在外部 API 无法显式知道的内部隐藏的机制</li>
<li>API 操作复杂度与对象数量成正比</li>
<li>API 对象状态不能依赖于网络连接状态</li>
<li>尽量避免让操作机制依赖于全局状态</li>
</ul>
<h2 id="架构设计原则">架构设计原则</h2>
<ul>
<li>只有 APIServer 可以直接访问 etcd 存储，其他服务必须通过 Kubernetes API 来访问集群状态；</li>
<li>所有组件都应该在内存中保持所需要的状态，APIServer 将状态写入 etcd 存储，而其他组件则通过 APIServer 更新并监听所有的变化；</li>
<li>优先使用事件监听而不是轮询。</li>
<li>假定我们的系统是一个开放的环境：应该不断的去验证系统假设，优雅地接受外部的事件和修改。比如用户可以随意地删除正在被 replica set 管理的 pods，而 replica set 发现了之后只是简单的重新创建一个新的 pod 而已。</li>
<li>不要为 object 建立大而全的状态机，从而把系统的行为和状态机的变迁关联起来。</li>
<li>单节点故障不应该影响集群的状态；不要假设所有的组件都能正常运行，任何组件都有可能出错或者拒绝你的请求。etcd 可能会拒绝写入，kubelet 可能会拒绝 pod， scheduler 可能会拒绝调度，尽量进行重试或者有别的解决方案。</li>
<li>在没有新请求的情况下，所有组件应该在故障恢复后继续执行上次最后收到的请求
（比如网络分区或服务重启等）；</li>
<li>系统组件能够自愈：比如说 cache 需要定期的进行同步，这样如果有一些 object 被错误的修改或者存储了， 删除的事件被丢失等问题能够在人类发现之前被自动修复。</li>
<li>优雅地进行降级和熔断，优先满足最重要的功能而忽略一些无关紧要的小错误。</li>
</ul>
<h2 id="kubenetes-api-习俗">kubenetes API 习俗</h2>
<p><strong>Spec and status</strong></p>
<ul>
<li>Spec 表示系统希望到达的状态，Status 表示系统目前观测到的状态。</li>
<li>PUT 和 POST 的请求中应该把 Status 段的数据忽略掉，Status 只能由系统组件来修改。</li>
<li>有一些对象可能跟 Spec 和 Status 模型相去甚远，可以吧 Spec 改成更加适合的名字。</li>
<li>如果对象符合 Spec 和 Status 的标准的话，那么除了 type，object metadata 之外不应该有其他顶级的字段。</li>
<li>Status 中 phase 已经是 deprecated。因为 pahse 本质上是状态机的枚举类型，它不太符合 Kubernetes 系统设计原则， 并且阻碍系统发展，因为每当你需要往里面加一个新的 pahse 的时候你总是很难做到向后兼容性，建议使用 Condition 来代替。</li>
</ul>
<p><strong>Primitive types</strong></p>
<ul>
<li>避免使用浮点数，永远不要在 Spec 中使用它们，浮点数不好规范化，在不同的语言和计算机体系结构中有 不同的精度和表示。</li>
<li>在 JavaScript 和其他的一部分语言中，所有的数字都会被转换成 float，所以数字超过了一定的大小最好使 用 string。</li>
<li>不要使用 unsigned integers，因为不同的语言和库对它的支持不一样。</li>
<li>不要使用枚举类型，建立一个 string 的别名类型。</li>
<li>API 中所有的 integer 都必须明确使用 G int64）, 不要使用 i 64 位的操作系统中他们的位数不一样。</li>
<li>谨慎地使用 bool 类型的字段，很多时候刚开始做 API 的时候是 true or false，但是随着系统的扩张，它可能 有多个可选值，多为未来打算。</li>
<li>对于可选的字段，使用指针来表示，比如 *string 这样就可以用 nil 来判断这个值是否设置了， 因为 Go 语言中 string int 这些类型都有零值，你无法判断他们是没被设置还是被设置了零值。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Etcd入门到实践</title>
			<link>https://whocanfly.gitee.io/posts/etcd%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/</link>
			<pubDate>Sat, 09 Apr 2022 11:26:27 +0800</pubDate>
			
			<guid>https://whocanfly.gitee.io/posts/etcd%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/</guid>
			<description>一、Etcd 简介 etcd 是一个强一致性的分布式键值对存储，设计用来可靠而快速的保存关键数据并提供访问。通过分布式锁，leader 选举和写屏障 (write barriers) 来</description>
			<content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/03/25/k3bIZ94PwCUYijD.jpg" alt="https//ilolinet/2021/03/25/k3bIZ94PwCUYijDjpg"></p>
<h2 id="一etcd-简介">一、Etcd 简介</h2>
<blockquote>
<p>etcd 是一个强一致性的分布式键值对存储，设计用来可靠而快速的保存关键数据并提供访问。通过分布式锁，leader 选举和写屏障 (write barriers) 来实现可靠的分布式协作。etcd 集群是为高可用，持久性数据存储和检索而准备的。</p>
<p>etcd 的场景默认处理的数据都是系统中的控制数据。所以 etcd 在系统中的角色不是其他 NoSQL 产品的替代品，更不能作为应用的主要数据存储。etcd 中应该尽量只存储系统中服务的配置信息，以此来实现 <strong>服务发现</strong>、<strong>分布式通知和协调</strong>，常见的还会使用 etcd 进行 <strong>主备选举</strong>、<strong>分布式锁</strong>、<strong>分布式数据队列</strong> 以及 <strong>服务健康监控</strong>。对于应用数据只推荐把数据量很小，但是更新和访问频次都很高的数据存储在 etcd 中。官方数据显示，etcd 单实例的写操作性能在 w 级别，读操作在 10w 级别</p>
</blockquote>
<h2 id="二etcd-工作原理">二、Etcd 工作原理</h2>
<h3 id="1核心组件">1、核心组件</h3>
<p><img src="https://i.loli.net/2021/03/23/QdSj6TnVAZtHEu4.png" alt="https//ilolinet/2021/03/23/QdSj6TnVAZtHEu4png"></p>
<p>Server：用于处理用户发送的 API 请求以及其它 <code>etcd</code> 节点的同步与心跳信息请求。</p>
<p>KV Store：用于处理 <code>etcd</code> 支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是 <code>etcd</code> 对用户提供的大多数 API 功能的具体实现，底层默认使用的是开源的嵌入式键值存储数据库 <a href="https://github.com/boltdb/bolt">bolt</a>，这个项目目前的状态已经是归档不再维护，如果想要使用这个项目可以使用 CoreOS 的 <a href="https://github.com/etcd-io/bbolt">bbolt</a> 版本。</p>
<p>Raft：Raft 强一致性算法的具体实现，是 <code>etcd</code> 的核心。</p>
<p>WAL：Write Ahead Log（预写式日志），是 <code>etcd</code> 的数据持久化存储方式。除了在内存中存有所有数据的状态以及节点的索引以外，<code>etcd</code> 就通过 WAL 进行持久化存储。WAL 中，所有的数据提交前都会事先记录日志。snapshot 是为了防止数据过多而进行快照压缩，默认每 10000 条记录做一次 <code>snapshot</code>, 经过 <code>snapshot</code> 以后的 WAL 文件就可以删除了。而通过 API 可以查询的历史 <code>etcd</code> 操作默认为 1000 条(v2 版本，v3 版本只要还未被压缩均能查到)；Entry 表示存储的具体日志内容</p>
<p>通常，一个用户的请求发送过来，会经由 Server 转发给 Store 进行具体的事务处理，如果涉及到节点的修改，则交给 Raft 模块进行状态变更、日志记录，然后再同步给其他的 <code>etcd</code> 节点以确认数据提交，最后进行数据的提交，再次同步。</p>
<h3 id="2数据一致性">2、数据一致性</h3>
<p><code>etcd</code> 集群是一个分布式系统，由多个节点相互通信构成整体对外服务，每个节点都存储了完整的数据，并且通过 Raft 协议保证每个节点维护的数据是一致的。在集群中的数据流向只有一个方向，即从 <code>Leader</code> （主节点）流向 <code>Follower</code>（从节点），当从节点收到写请求后均会自动转发到主节点，从节点甚至不需要知道谁是主节点，并由主节点执行写操作，然后追加日志同步到集群所有节点，也就是说所有 <code>Follower</code> 的数据必须与 <code>Leader</code> 保持一致，如果不一致则会被覆盖。从用户的角度来说，对 <code>etcd</code> 集群中的所有节点进行读写效果是一样的。</p>
<p>既然写操作涉及到节点间的数据同步，那么到底如何界定一个写入操作是成功的？<code>etcd</code> 认为写入请求被 <code>Leader</code> 节点处理并分发给了<code>Quorum(N/2+1)</code>个节点后，就是一个成功的写入。</p>
<p>为了保证数据的一致性，那么无论何时集群中必须有且只有一个有效的 <code>Leader</code>, 所以 <code>etcd</code> 通过 Raft 协议来选举 <code>Leader</code>。首先，需要明确的是在选举过程中会出现三种角色，它们的关系如下图，其中 <code>Candidate</code> 是在选举期间才会出现的角色，正常的 <code>etcd</code> 集群只有 <code>Leader</code> 和 <code>Folower</code>。</p>
<p><img src="https://i.loli.net/2021/03/22/VuDn3ceI4k1lpEm.png" alt="https//ilolinet/2021/03/22/VuDn3ceI4k1lpEmpng"></p>
<p><strong>大致选举流程：</strong></p>
<ol>
<li>集群初始化时，所有节点都处于 <code>Follower</code> 状态，当 <code>Follower</code> 一段时间 (<code>选举计时器</code>超时) 收不到 <code>Leader</code> 的心跳消息，就认为 <code>Leader</code>出现故障导致其任期 (<code>Term</code>) 过期，<code>Follower</code> 会转成 <code>Candidate</code>；</li>
<li><code>Candidate</code> 等<code>选举计时器</code>超时后，会先投自己一票，并向集群中其他节点发起选举请求，并带上自己的 Term ID 以及当前日志的 Max Index（确保新选举的 <code>Leader</code> 有最全的日志）;</li>
<li>如果其他节点在 Term ID 内还没有投票，就会比较 <code>Candidate</code> 的 Max Index 是否比自己小，如果比自己大或者相等，就会投票给 <code>Candidate</code>；同时，会将自己的<code>选举计时器</code>重置；</li>
<li><code>Candidate</code> 在获取到超过半数节点的选票后，升级为 <code>Leader</code>；并按照<code>心跳计时器</code>向集群中其他节点发送心跳报文，并同步日志等；<code>Follower</code> 收到心跳报文后，会重置<code>选举计时器</code>。</li>
</ol>
<h3 id="3数据模型">3、数据模型</h3>
<p><code>ectd</code> 提供了一个持久化、多版本、并发控制的数据模型，当键值对的值需要被新的数据替代时，<code>etcd</code> 还会继续保存先前版本的键值对。键值存储事实上是不可变的；它的操作不会就地更新结构，取而代之的是生成一个新的更新后的结构。在修改之后，<code>key</code> 的所有先前版本还是可以访问和监控的。为了防止维护老版本导致数据存储无限增长，存储应该被压缩来移除旧的版本，一旦存储被压缩来恢复空间，在压缩修订版本之前的修订版本都会被移除，即不可访问和监控。</p>
<p>在物理视图上，<code>etcd</code> 以 <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+ 树</a> 键值对的方式来存储物理数据，为了追求效率，存储的是当前修订版本与上一个修订版本间的差异（增量），单个修订版本的数据可能对应到 B+ 树上的多个键。需要说明的是，B+ 树上存储的键是一个三元组 <code>revision</code> (<code>major</code>, <code>sub</code>, <code>type</code>)，<code>major</code> 是持有 <code>key</code> 的存储修订版本、<code>sub</code> 区分同一个修订版本的不同 <code>key</code>、<code>type</code> 是用于特殊值的可选后缀。B+ 树的 key 空间的字符串按 <strong>字典序</strong> 排序，所以可以高效的支持 <strong>范围查询</strong>。</p>
<p>除了使用 B+ 树 这种数据结构来持久化数据之外，<code>etcd</code> 还通过在内存中维护一棵 B 树索引来加速键的范围查询，<code>key</code> 是存储暴露给用户的 <code>key</code>。值是到持久化 B+ 树修改的指针。</p>
<h3 id="4修订版本">4、修订版本</h3>
<ul>
<li><code>Revision</code> 表示改动序号（ID），每次 KV 的变化，leader 节点都会修改 <code>Revision</code> 值，因此，这个值在 <code>cluster</code> 内是全局唯一的，而且是递增的</li>
<li><code>ModRevison</code> 记录了某个 <code>key</code> 最近修改时的 Revision，即它是与 <code>key</code> 关联的</li>
<li><code>CreateRevision</code> 与<code>ModRevison</code>类似、记录的是某个<code>key</code>创建时的 <code>Revision</code></li>
<li><code>Version</code> 表示 KV 的版本号，初始值为 <code>1</code>，每次修改 KV 对应的 <code>Version</code> 都会加 <code>1</code>，也就是说它是作用在 KV 之内的， 与其他 KV 无关</li>
</ul>
<h3 id="5etcd-v3-的-mvcc-实现">5、Etcd v3 的 MVCC 实现</h3>
<p><code>etcd</code> 在 BoltDB 中存储的 key 是 <code>revision</code>，<code>value</code> 是 <code>etcd</code> 自己的 <code>key-value</code> 组合，也就是说 <code>etcd</code> 会在 BoltDB 中保存每个版本，从而实现多版本控制。</p>
<p>所以 <code>etcd</code> 在BoltDB 中查询数据时必须通过 <code>revision</code>，而客户端是通过 <code>key</code> 来查询 <code>value</code> 的，因此 <code>etcd</code> 还在内存中维护了一个 <code>kvindex</code>，用于保存 <code>key</code> 与 <code>revision</code> 之间的映射关系，也就是前文提到的 B 树索引。这样查询路径就变为：客户端提供 <code>key</code> =&gt; <code>etcd</code> 通过 <code>key</code> 在 <code>kvindex</code> 中查到对应的 <code>revision</code> =&gt; 接着通过 <code>revision</code> 在 BoltDB 查询 <code>value</code> =&gt; 最后将 <code>value</code> 返回给客户端</p>
<p>在内存的索引中，每个用户的原始 <code>key</code>都关联了一个 <code>keyIndex</code> 结构， 如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">keyIndex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 用户的原始 key
</span><span class="c1"></span>    <span class="nx">key</span>          <span class="p">[]</span><span class="kt">byte</span>
    <span class="c1">// 最近一次修改时 key 对应的 revision
</span><span class="c1"></span>    <span class="nx">modified</span>     <span class="nx">revison</span>
    <span class="c1">// key 的生命周期，第一次创建的 key 是 generations[0], 标记为删除后再次创建则为 generations[1]
</span><span class="c1"></span>    <span class="nx">generations</span>  <span class="p">[]</span><span class="nx">generation</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">generation</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// key 的版本，每次创建都是从零开始，之后每次更新都自增
</span><span class="c1"></span>    <span class="nx">ver</span>       <span class="kt">int64</span>
    <span class="c1">// key 创建时的 revision
</span><span class="c1"></span>    <span class="nx">created</span>   <span class="nx">revision</span>
    <span class="c1">// 用于记录每次更新时的 key 对应的 revision
</span><span class="c1"></span>    <span class="nx">revs</span>      <span class="p">[]</span><span class="nx">revision</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">revision</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 唯一事务ID, 全局递增且不重复，一个事务里可以对多个 key 进行更新操作，但每个 key 最多只能更新一次
</span><span class="c1"></span>    <span class="nx">main</span> <span class="kt">int64</span>
    <span class="c1">// 标记有更新操作的 key，在每个事务内都是从零开始递增编号
</span><span class="c1"></span>    <span class="nx">sub</span>  <span class="kt">int64</span>
<span class="p">}</span>
</code></pre></div><p>综上，内存 B 树维护的是 <code>key</code> 到 <code>keyIndex</code> 之间的映射关系（<code>kvindex</code>），<code>keyIndex</code>内维护的是一个 <code>key</code> 对应多个版本的 <code>revision</code> 信息，而通过 <code>revision</code> 就可以在 BoltDB 中查询到对应的 <code>value</code>了。</p>
<h2 id="三etcdctl-基本操作">三、etcdctl 基本操作</h2>
<h3 id="1查看版本">1、查看版本</h3>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">etcdctl version
</code></pre></div><h3 id="2写入">2、写入</h3>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">etcdctl put &lt;key&gt; &lt;value&gt;
</code></pre></div><h3 id="3读取">3、读取</h3>
<pre><code>// 读取键和值
etcdctl get &lt;key&gt;
// 只读取键
etcdctl get &lt;key&gt; --keys-only
// 读取某些前缀的键
etcdctl get &lt;key&gt; --prefix --keys-only
// 只读取值
etcdctl get &lt;key&gt; --print-value-only
// 读取某个范围的值
etcdctl get &lt;key1&gt; &lt;key2&gt;
// 读取 /test 为前缀的 key， 并限制数量为 3
etcdctl get /test --prefix --limit=3
// 因为 etcd 集群上键值存储的每个修改都会增加 etcd 集群的全局修订版本，应用可以通过提供旧有的 etcd 修改版本来读取被替代的键。
// 读取历史版本: 修订版本号为 vision=230
etcdctl get &lt;key&gt; --rev=230 --prefix
// 读取大于等于键 /test/key 的 byte 值的键
etcdctl get --from-key /test/key
// 以json格式输出
etcdctl get &lt;key&gt; --prefix --write-out=json
// 输出详细的信息
etcdctl get &lt;key&gt; --prefix --write-out=fields
</code></pre><h3 id="4删除">4、删除</h3>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">// 删除一个键值对
etcdctl del &lt;key&gt;
// 删除键 &lt;key&gt; 并返回删除数以及被删除的键值对
etcdctl del --prev-kv &lt;key&gt;
// 删除 key1 到 key2 之间的键
etcdctl del &lt;key1&gt; &lt;key2&gt;
// 删除 /test 前缀的 key
etcdctl del /test --prefix
// 删除大于等于键 /test/key 的 byte 值的键
etcdctl del --from-key /test/key
</code></pre></div><h3 id="5监控-watch">5、监控 watch</h3>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">// 监控 &lt;key&gt; 的变化
etcdctl watch &lt;key&gt;
// 监控 &lt;key1&gt; 到 &lt;key2&gt; 范围的键
etcdctl watch &lt;key1&gt; &lt;key2&gt;
// 监控以 /test 为前缀的key
etcdctl watch /test --prefix
// 监控多个键
etcdctl watch -i
etcdctl watch &lt;key1&gt;
etcdctl watch &lt;key2&gt;
// 监控 key 的历史变动, 从 vision 为 <span class="m">3</span> 开始
etcdctl watch --rev<span class="o">=</span><span class="m">3</span> &lt;key&gt;
</code></pre></div><h3 id="6压缩修订版本">6、压缩修订版本</h3>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">// 被压缩的历史版本不能被查询
etcdctl compact &lt;vision&gt;

eg
$ etcdctl compact <span class="m">250</span>
compacted revision <span class="m">250</span>

$ etcdctl get /test --prefix --rev<span class="o">=</span><span class="m">249</span>
...mvcc: required revision has been compacted
</code></pre></div><h3 id="7授予租约">7、授予租约</h3>
<p>应用可以为 <code>etcd</code> 集群里面的键授予租约。当键被附加到租约时，它的存活时间被绑定到租约的存活时间，而租约的存活时间相应的被 <code>time-to-live</code> (TTL) 管理。在租约授予时每个租约的最小 TTL 值由应用指定。租约的实际 TTL 值是不低于最小 TTL，由 <code>etcd</code> 集群选择。一旦租约的 TTL 到期，租约就过期并且所有附带的键都将被删除。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">// 授予租约， TTL 为 10s
$ etcdctl lease grant <span class="m">10</span>
lease 694d77e7d63d678f granted with TTL<span class="o">(</span>10s<span class="o">)</span>
// 将租约绑定到键上
etcdctl put --lease<span class="o">=</span>694d77e7d63d678f &lt;key&gt; &lt;value&gt;
</code></pre></div><h3 id="8撤销租约">8、撤销租约</h3>
<p>应用通过租约 id 可以撤销租约， 撤销租约将删除所有它附带的 key。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">etcdctl lease revoke 694d77e7d63d678f
</code></pre></div><h3 id="9维持租约">9、维持租约</h3>
<p>租约到期时、会自动续约，此命令会阻塞命令行</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">etcdctl lease keep-alive 694d77e7d63d678f
</code></pre></div><h3 id="10获取租约信息">10、获取租约信息</h3>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">// 返回租约时间以及剩余时间
$ etcdctl lease timetolive 694d77e7d63d67a4
lease 694d77e7d63d67a4 granted with TTL<span class="o">(</span>30s<span class="o">)</span>, remaining<span class="o">(</span>27s<span class="o">)</span>
// 返回租约时间以、剩余时间以及租约附带的key
$ etcdctl lease timetolive --keys 694d77e7d63d67a4
lease 694d77e7d63d67a4 granted with TTL<span class="o">(</span>30s<span class="o">)</span>, remaining<span class="o">(</span>28s<span class="o">)</span>, attached keys<span class="o">([</span>/test/bbb /test/aaa<span class="o">])</span>
</code></pre></div><h2 id="四golang-客户端简单示例">四、golang 客户端简单示例</h2>
<blockquote>
<p>使用官方的 etcd/clientv3 包来连接 etcd 并进行相关操作</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">etcd</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;context&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;github.com/coreos/etcd/clientv3&#34;</span>
    <span class="s">&#34;github.com/coreos/etcd/clientv3/concurrency&#34;</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;os&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">client</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
    <span class="nx">client</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
        <span class="nx">Endpoints</span><span class="p">:</span>   <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;127.0.0.1:2379&#34;</span><span class="p">},</span>
        <span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
    <span class="p">})</span>

    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;init client fail&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;connect success, %s&#34;</span><span class="p">,</span> <span class="nx">client</span><span class="p">.</span><span class="nx">Username</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetClient</span><span class="p">()</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">client</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;put to etcd failed, err:%v\\\\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="c1">// 使用租约
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">PutWithLease</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ttl</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">LeaseID</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">grant</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Grant</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ttl</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;PutWithLease to etcd failed, err:%v\\\\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithLease</span><span class="p">(</span><span class="nx">grant</span><span class="p">.</span><span class="nx">ID</span><span class="p">))</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;PutWithLease to etcd failed, err:%v\\\\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">grant</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Del</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;del to etcd failed, err:%v\\\\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;get from etcd failed, err:%v\\\\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&#34;&#34;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Kvs</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;index: %d, keyValue: %s&#34;</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Kvs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Value</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 获取以key为前缀的kv
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetWithPrefix</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">resp</span> <span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">get</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithPrefix</span><span class="p">())</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;GetWithPrefix from etcd failed, err:%v\\\\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">resp</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">get</span><span class="p">.</span><span class="nx">Kvs</span> <span class="p">{</span>
        <span class="c1">//log.Printf(&#34;index: %d, keyValue: %s&#34;, k, v)
</span><span class="c1"></span>        <span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
        <span class="nx">m</span><span class="p">[</span><span class="nb">string</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Key</span><span class="p">)]</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
        <span class="nx">resp</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">resp</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">resp</span>
<span class="p">}</span>

<span class="c1">// 监控机制
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Watch</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">watch</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Watch</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithPrefix</span><span class="p">())</span>
    <span class="k">for</span> <span class="nx">w</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">watch</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ev</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Events</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;watch type: %s, k: %s, v: %s\\\\n&#34;</span><span class="p">,</span> <span class="nx">ev</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">ev</span><span class="p">.</span><span class="nx">Kv</span><span class="p">.</span><span class="nx">Key</span><span class="p">),</span> <span class="nb">string</span><span class="p">(</span><span class="nx">ev</span><span class="p">.</span><span class="nx">Kv</span><span class="p">.</span><span class="nx">Value</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Clear</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithPrefix</span><span class="p">())</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;clear etcd fail, %v\\\\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="五基于-etcd-的分布式锁实践">五、基于 Etcd 的分布式锁实践</h2>
<blockquote>
<p>基于 etcd 客户端实现分布式锁，etcd 实现分布式锁的基础是 Lease (租约) 机制、Revision（修订版本号） 机制、Prefix 机制、Watch 机制</p>
<ul>
<li>Lease 机制：即租约机制（TTL，Time To Live），etcd 可以为存储的 key-value 对设置租约，当租约到期，key-value 将失效删除；同时也支持续约续期（KeepAlive）</li>
<li>Revision 机制：每个 <code>key</code> 带有一个 <code>Revision</code> 属性值，Etcd 每进行一次事务对应的全局 <code>Revision</code> 值都会加一，因此每个 Key 对应的 <code>Revision</code> 属性值都是全局唯一的。通过比较 <code>Revision</code> 的大小就可以知道进行写操作的顺序。在实现分布式锁时，多个程序同时抢锁，根据 <code>Revision</code> 值大小依次获得锁，可以避免惊群效应，实现公平锁</li>
<li>Prefix 机制：即前缀机制（或目录机制）。可以根据前缀（目录）获取该目录下所有的 Key 及对应的属性（包括 Key、Value 以及 <code>Revision</code> 等）</li>
<li>Watch 机制：即监听机制，Watch 机制支持 Watch 某个固定的 Key，也支持 Watch 一个目录前缀（前缀机制），当被 Watch 的 Key 或目录发生变化，客户端将收到通知</li>
</ul>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Lock</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 获取两个session模拟锁竞争
</span><span class="c1"></span>    <span class="nx">session1</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">concurrency</span><span class="p">.</span><span class="nf">NewSession</span><span class="p">(</span><span class="nx">client</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;get session fail, %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">session2</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">concurrency</span><span class="p">.</span><span class="nf">NewSession</span><span class="p">(</span><span class="nx">client</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;get session fail, %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">lock</span> <span class="o">:=</span> <span class="s">&#34;/test/lock&#34;</span>
    <span class="nx">locker1</span> <span class="o">:=</span> <span class="nx">concurrency</span><span class="p">.</span><span class="nf">NewLocker</span><span class="p">(</span><span class="nx">session1</span><span class="p">,</span> <span class="nx">lock</span><span class="p">)</span>
    <span class="nx">locker2</span> <span class="o">:=</span> <span class="nx">concurrency</span><span class="p">.</span><span class="nf">NewLocker</span><span class="p">(</span><span class="nx">session2</span><span class="p">,</span> <span class="nx">lock</span><span class="p">)</span>

    <span class="nx">locker1</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;get lock for session1&#34;</span><span class="p">)</span>

    <span class="nx">locked</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">locked</span><span class="p">)</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;before locker2 lock&#34;</span><span class="p">)</span>
        <span class="c1">// 阻塞知道等待session1释放锁
</span><span class="c1"></span>        <span class="nx">locker2</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;after locker2 lock&#34;</span><span class="p">)</span>
    <span class="p">}()</span>

    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="c1">// session1 释放锁
</span><span class="c1"></span>    <span class="nx">locker1</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;session1 unlocked&#34;</span><span class="p">)</span>

    <span class="o">&lt;-</span><span class="nx">locked</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;get lock for session2&#34;</span><span class="p">)</span>

    <span class="nx">locker2</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;session2 unlocked&#34;</span><span class="p">)</span>

<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">2021-03-23 21:40:10.184063 I <span class="p">|</span> connect success,
2021-03-23 21:40:10.302807 I <span class="p">|</span> watch type: PUT, k: /test/lock/694d785eff30693d, v:
2021-03-23 21:40:10.302807 I <span class="p">|</span> get lock <span class="k">for</span> session1
2021-03-23 21:40:10.302807 I <span class="p">|</span> before locker2 lock
2021-03-23 21:40:10.303807 I <span class="p">|</span> watch type: PUT, k: /test/lock/694d785eff30693f, v:
2021-03-23 21:40:11.304476 I <span class="p">|</span> session1 unlocked
2021-03-23 21:40:11.304476 I <span class="p">|</span> watch type: DELETE, k: /test/lock/694d785eff30693d, v:
2021-03-23 21:40:11.309478 I <span class="p">|</span> after locker2 lock
2021-03-23 21:40:11.309478 I <span class="p">|</span> get lock <span class="k">for</span> session2
2021-03-23 21:40:11.310478 I <span class="p">|</span> session2 unlocked
2021-03-23 21:40:11.310478 I <span class="p">|</span> watch type: DELETE, k: /test/lock/694d785eff30693f, v:
</code></pre></div><h2 id="六基于-etcd-的分布式系统主备选举实践">六、基于 Etcd 的分布式系统主备选举实践</h2>
<p>日常开发中，为了避免服务的单点故障，我们通常会采用分布式架构的形式，但在某些场景下我们希望某些功能只由特定的节点执行，这些功同时能被多个节点同时执行的话可能导致数据不一致，所以我们的系统可以通过选举出 <code>leader</code> 的方式来避免这些问题，而基于 <code>Ralf</code> 协议的 <code>etcd</code> 就是一个实现分布式系统选举可靠的中间件，与实现分布式锁类似，实现选举也要依赖于 <code>lease</code> (租约) 机制、<code>revision</code>（修订版本号） 机制、<code>prefix</code> 机制、<code>watch</code> 机制</p>
<p><code>concurrency</code> 包实现选举的方法主要如下：</p>
<p><img src="https://i.loli.net/2021/03/25/G8Scuy7LINbxq5m.png" alt="https//ilolinet/2021/03/25/G8Scuy7LINbxq5mpng"></p>
<p>示例中主要会使用的方法是 concurrency.NewElection, concurrency.Election.Campaign, concurrency.Election.Resign</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Campaign</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">TODO</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 为client创建session，并绑定租约，租约的ttl为5s, 如传入的ttl&lt;0, 将使用默认的ttl（60s）
</span><span class="c1"></span>        <span class="nx">session</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">concurrency</span><span class="p">.</span><span class="nf">NewSession</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="nx">concurrency</span><span class="p">.</span><span class="nf">WithTTL</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>

        <span class="c1">// campaignPrefix 是需要监听的目录前缀，发起选举会自动在末尾补 `/`
</span><span class="c1"></span>        <span class="nx">campaignPrefix</span> <span class="o">:=</span> <span class="s">&#34;/test/campaign&#34;</span>
        <span class="nx">election</span> <span class="o">:=</span> <span class="nx">concurrency</span><span class="p">.</span><span class="nf">NewElection</span><span class="p">(</span><span class="nx">session</span><span class="p">,</span> <span class="nx">campaignPrefix</span><span class="p">)</span>
        <span class="nx">hostname</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Hostname</span><span class="p">()</span>
        <span class="nx">campaignId</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s-%d&#34;</span><span class="p">,</span> <span class="nx">hostname</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getpid</span><span class="p">())</span>
        <span class="c1">// 1、以 keyPrefix + leaseId 为 key, campaignId 为 value 创建键值对
</span><span class="c1"></span>        <span class="c1">// 2、一直阻塞除非成功选举为 Leader 或者 context 过期
</span><span class="c1"></span>        <span class="c1">// 3、成功选举为 Leader 的条件是当前 key 比 keyPrefix 目录下的其他 key 的 CreateRevision 小
</span><span class="c1"></span>        <span class="c1">// 4、每个 key 都监听（等待）比自己 CreateRevision 小但 CreateRevision 最大的 key 被删除
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">election</span><span class="p">.</span><span class="nf">Campaign</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">campaignId</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
                <span class="k">return</span>
            <span class="k">default</span><span class="p">:</span>
            <span class="p">}</span>
            <span class="k">continue</span>
        <span class="p">}</span>

        <span class="nx">Leader</span> <span class="p">=</span> <span class="nx">campaignId</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;leader: %s\\\\n&#34;</span><span class="p">,</span> <span class="nx">Leader</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">LeaderShouldDo</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nf">LeaderShouldDo</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">session</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
            <span class="c1">// 放弃 Leader 的身份，重新发起新一轮选举
</span><span class="c1"></span>            <span class="nx">election</span><span class="p">.</span><span class="nf">Resign</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
            <span class="nx">session</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
            <span class="k">if</span> <span class="nx">QuitLeader</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nf">QuitLeader</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s quit leader\\\\n&#34;</span><span class="p">,</span> <span class="nx">Leader</span><span class="p">)</span>
            <span class="nx">Leader</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
            <span class="k">continue</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
            <span class="nx">session</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
            <span class="k">if</span> <span class="nx">QuitLeader</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nf">QuitLeader</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s quit leader\\\\n&#34;</span><span class="p">,</span> <span class="nx">Leader</span><span class="p">)</span>
            <span class="nx">Leader</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>假设系统中有三个节点，如图，3 节点监听 2 节点，2 节点监听 1 节点，1 节点是 Leader</p>
<p>1）假如 2 节点租约过期了，那么 3 节点将监听 1 节点</p>
<p>2） 假如 1 节点的租约过期了，那么 2 节点成为 Leader</p>
<p><img src="https://i.loli.net/2021/03/25/GfwiCYLs3xZgXDz.png" alt="https//ilolinet/2021/03/25/GfwiCYLs3xZgXDzpng"></p>
<p><strong>启动三个 client后依次停止client1、client2、client3</strong></p>
<p><strong>client1</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">2021-03-25 15:30:44.036311 I <span class="p">|</span> connect success,
2021-03-25 15:30:44.140412 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d786823c4fd87, v: chenhongbin-25712
2021-03-25 15:30:44.148287 I <span class="p">|</span> leader: chenhongbin-25712
2021-03-25 15:30:50.267831 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d786823c4fd8b, v: chenhongbin-27112
2021-03-25 15:30:55.430359 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d786823c4fd8f, v: chenhongbin-24684
2021-03-25 15:31:15.770408 I <span class="p">|</span> chenhongbin-25712 quit leader
2021-03-25 15:31:15.770913 I <span class="p">|</span> watch type: DELETE, k: /test/campaign/694d786823c4fd87, v:
</code></pre></div><p><strong>client2</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">2021-03-25 15:30:50.171378 I <span class="p">|</span> connect success,
2021-03-25 15:30:50.268338 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d786823c4fd8b, v: chenhongbin-27112
2021-03-25 15:30:55.430359 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d786823c4fd8f, v: chenhongbin-24684
2021-03-25 15:31:15.770408 I <span class="p">|</span> watch type: DELETE, k: /test/campaign/694d786823c4fd87, v:
2021-03-25 15:31:15.775075 I <span class="p">|</span> leader: chenhongbin-27112
2021-03-25 15:31:18.673096 I <span class="p">|</span> chenhongbin-27112 quit leader
2021-03-25 15:31:18.673096 I <span class="p">|</span> watch type: DELETE, k: /test/campaign/694d786823c4fd8b, v:
</code></pre></div><p><strong>client3</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">2021-03-25 15:30:55.373742 I <span class="p">|</span> connect success,
2021-03-25 15:30:55.430359 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d786823c4fd8f, v: chenhongbin-24684
2021-03-25 15:31:15.770408 I <span class="p">|</span> watch type: DELETE, k: /test/campaign/694d786823c4fd87, v:
2021-03-25 15:31:18.673096 I <span class="p">|</span> watch type: DELETE, k: /test/campaign/694d786823c4fd8b, v:
2021-03-25 15:31:18.678095 I <span class="p">|</span> leader: chenhongbin-24684
2021-03-25 15:31:32.872987 I <span class="p">|</span> chenhongbin-24684 quit leader
2021-03-25 15:31:32.872987 I <span class="p">|</span> watch type: DELETE, k: /test/campaign/694d786823c4fd8f, v:
</code></pre></div><p><strong>启动三个 client后依次停止 etcd 服务模拟网络异常，等待租约过期重新启动服务</strong></p>
<p><strong>client1</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">2021-03-25 15:34:10.450527 I <span class="p">|</span> connect success,
2021-03-25 15:34:10.547423 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d786823c4fd98, v: chenhongbin-24980
2021-03-25 15:34:10.549421 I <span class="p">|</span> leader: chenhongbin-24980
2021-03-25 15:34:14.898319 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d786823c4fd9c, v: chenhongbin-21324
2021-03-25 15:34:20.017620 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d786823c4fda0, v: chenhongbin-13260
2021-03-25 15:34:54.375748 I <span class="p">|</span> watch type: DELETE, k: /test/campaign/694d786823c4fd98, v:
2021-03-25 15:34:54.377772 I <span class="p">|</span> chenhongbin-24980 quit leader
2021-03-25 15:34:54.379744 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d78684eb7fb06, v: chenhongbin-24980
2021-03-25 15:34:54.530581 I <span class="p">|</span> watch type: DELETE, k: /test/campaign/694d786823c4fd9c, v:
2021-03-25 15:34:54.547818 I <span class="p">|</span> watch type: DELETE, k: /test/campaign/694d786823c4fda0, v:
2021-03-25 15:34:54.559815 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d78684eb7fb0f, v: chenhongbin-21324
2021-03-25 15:34:54.559815 I <span class="p">|</span> leader: chenhongbin-24980
2021-03-25 15:34:54.562814 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d78684eb7fb14, v: chenhongbin-13260
</code></pre></div><p><strong>client2</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">2021-03-25 15:34:14.798817 I <span class="p">|</span> connect success,
2021-03-25 15:34:14.898319 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d786823c4fd9c, v: chenhongbin-21324
2021-03-25 15:34:20.017620 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d786823c4fda0, v: chenhongbin-13260
2021-03-25 15:34:54.381756 I <span class="p">|</span> watch type: DELETE, k: /test/campaign/694d786823c4fd98, v:
2021-03-25 15:34:54.381756 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d78684eb7fb06, v: chenhongbin-24980
2021-03-25 15:34:54.483051 I <span class="p">|</span> leader: chenhongbin-21324
2021-03-25 15:34:54.534824 I <span class="p">|</span> watch type: DELETE, k: /test/campaign/694d786823c4fd9c, v:
2021-03-25 15:34:54.544816 I <span class="p">|</span> chenhongbin-21324 quit leader
2021-03-25 15:34:54.547818 I <span class="p">|</span> watch type: DELETE, k: /test/campaign/694d786823c4fda0, v:
2021-03-25 15:34:54.559815 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d78684eb7fb0f, v: chenhongbin-21324
2021-03-25 15:34:54.562814 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d78684eb7fb14, v: chenhongbin-13260
</code></pre></div><p><strong>client3</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">2021-03-25 15:34:19.897700 I <span class="p">|</span> connect success,
2021-03-25 15:34:20.017620 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d786823c4fda0, v: chenhongbin-13260
2021-03-25 15:34:54.375748 I <span class="p">|</span> watch type: DELETE, k: /test/campaign/694d786823c4fd98, v:
2021-03-25 15:34:54.380743 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d78684eb7fb06, v: chenhong
bin-24980
2021-03-25 15:34:54.530581 I <span class="p">|</span> watch type: DELETE, k: /test/campaign/694d786823c4fd9c, v:
2021-03-25 15:34:54.543815 I <span class="p">|</span> leader: chenhongbin-13260
2021-03-25 15:34:54.547818 I <span class="p">|</span> watch type: DELETE, k: /test/campaign/694d786823c4fda0, v:
2021-03-25 15:34:54.559815 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d78684eb7fb0f, v: chenhongbin-21324
2021-03-25 15:34:54.559815 I <span class="p">|</span> chenhongbin-13260 quit leader
2021-03-25 15:34:54.562814 I <span class="p">|</span> watch type: PUT, k: /test/campaign/694d78684eb7fb14, v: chenhongbin-13260
</code></pre></div><h2 id="七基于-etcd-服务发现实践">七、基于 Etcd 服务发现实践</h2>
<p>所谓服务发现就是了解集群中是否有进程在监听 UDP 或者 TCP 端口，并且通过名字就可以进行查找和链接，因为在微服务中，一个服务重启后其 <code>endpoint</code> 极有可能发生变化</p>
<p>满足服务发现的条件：</p>
<ol>
<li>服务注册：强一致性、高可用的服务存储目录，基于 Raft 算法的 <code>etcd</code> 天生就是这样一个强一致性、高可用的服务存储目录，以此来实现服务注册</li>
<li>健康检查：租约机制可用来实现服务健康状况检测，定时续约以达到监控健康状态的效果</li>
<li>服务发现：watch 机制，可以及时发现注册服的更新、删除</li>
</ol>
<p><img src="https://i.loli.net/2021/06/04/EGBYDXaNt3ClzQ1.png" alt="https//ilolinet/2021/06/04/EGBYDXaNt3ClzQ1png"></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">etcd</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;context&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;github.com/coreos/etcd/clientv3&#34;</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">DiscoveryRoot</span> <span class="p">=</span> <span class="s">&#34;/discovery&#34;</span>

<span class="kd">type</span> <span class="nx">serviceRegisterDiscovery</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">mux</span>              <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="nx">ctx</span>              <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
    <span class="nx">leaseIdMap</span>       <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">LeaseID</span>
    <span class="nx">serviceName</span>      <span class="kt">string</span>
    <span class="nx">keepAliveChanMap</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">&lt;-</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">LeaseKeepAliveResponse</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewServiceRegisterDiscovery</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">serviceName</span> <span class="nx">str</span>    <span class="nx">ing</span><span class="p">)</span> <span class="o">*</span><span class="nx">serviceRegisterDiscovery</span> <span class="p">{</span>
    <span class="nx">leaseIdMap</span><span class="p">,</span> <span class="nx">keepAliveChanMap</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">LeaseID</span><span class="p">),</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">&lt;-</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">LeaseKeepAliveResponse</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">serviceRegisterDiscovery</span><span class="p">{</span>
        <span class="nx">leaseIdMap</span><span class="p">:</span>       <span class="nx">leaseIdMap</span><span class="p">,</span>
        <span class="nx">serviceName</span><span class="p">:</span>      <span class="nx">serviceName</span><span class="p">,</span>
        <span class="nx">keepAliveChanMap</span><span class="p">:</span> <span class="nx">keepAliveChanMap</span><span class="p">,</span>
        <span class="nx">ctx</span><span class="p">:</span>              <span class="nx">ctx</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">serviceRegisterDiscovery</span><span class="p">)</span> <span class="nf">key</span><span class="p">(</span><span class="nx">endpoint</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s/%s/%s&#34;</span><span class="p">,</span> <span class="nx">DiscoveryRoot</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">serviceName</span><span class="p">,</span> <span class="nx">endpoint</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">serviceRegisterDiscovery</span><span class="p">)</span> <span class="nf">Register</span><span class="p">(</span><span class="nx">endpoint</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">lease</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">mux</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">s</span><span class="p">.</span><span class="nx">mux</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="nx">key</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">key</span><span class="p">(</span><span class="nx">endpoint</span><span class="p">)</span>
    <span class="nx">leaseId</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">PutWithLease</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">endpoint</span><span class="p">,</span> <span class="nx">lease</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="c1">// 自动续约
</span><span class="c1"></span>    <span class="nx">keepAliveChan</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">KeepAlive</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">leaseId</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="nx">s</span><span class="p">.</span><span class="nx">leaseIdMap</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="nx">s</span><span class="p">.</span><span class="nx">keepAliveChanMap</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">leaseId</span><span class="p">,</span> <span class="nx">keepAliveChan</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">serviceRegisterDiscovery</span><span class="p">)</span> <span class="nf">ListenLeaseChan</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">keepAliveChanMap</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">length</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">keepAliveChanMap</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">length</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">ch</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">keepAliveChanMap</span> <span class="p">{</span>
            <span class="nx">i</span><span class="o">++</span>
            <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>
                    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="s">&#34;keepalive successful&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Revision</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}()</span>
            <span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">length</span><span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
        <span class="nx">length</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">keepAliveChanMap</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;all lease of %s is canceled&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">serviceName</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">serviceRegisterDiscovery</span><span class="p">)</span> <span class="nf">CloseService</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">leasId</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">leaseIdMap</span> <span class="p">{</span>
        <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Revoke</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">leasId</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">leaseIdMap</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">serviceRegisterDiscovery</span><span class="p">)</span> <span class="nf">CancelEndpoint</span><span class="p">(</span><span class="nx">endpoint</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">leaseId</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">leaseIdMap</span><span class="p">[</span><span class="nx">s</span><span class="p">.</span><span class="nf">key</span><span class="p">(</span><span class="nx">endpoint</span><span class="p">)]</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Revoke</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">leaseId</span><span class="p">)</span>
    <span class="nb">delete</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">leaseIdMap</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">key</span><span class="p">(</span><span class="nx">endpoint</span><span class="p">))</span>
    <span class="nb">delete</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">keepAliveChanMap</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">key</span><span class="p">(</span><span class="nx">endpoint</span><span class="p">))</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">serviceRegisterDiscovery</span><span class="p">)</span> <span class="nf">Discovery</span><span class="p">()</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">services</span> <span class="p">[]</span><span class="kt">string</span>
    <span class="nx">prefix</span> <span class="o">:=</span> <span class="nf">GetWithPrefix</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">key</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">))</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">prefix</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">p</span> <span class="p">{</span>
            <span class="nx">services</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">services</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">services</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">etcd</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;math/rand&#34;</span>
    <span class="s">&#34;testing&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">TestNewServiceRegisterDiscovery</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">svcRegisterDiscovery</span> <span class="o">:=</span> <span class="nf">NewServiceRegisterDiscovery</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;web&#34;</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nx">svcRegisterDiscovery</span><span class="p">.</span><span class="nf">CloseService</span><span class="p">()</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="nx">discovery</span> <span class="o">:=</span> <span class="nx">svcRegisterDiscovery</span><span class="p">.</span><span class="nf">Discovery</span><span class="p">()</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">discovery</span><span class="p">)</span>
            <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
            <span class="nx">endpoint</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;127.0.0.1:909%d&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
            <span class="nx">err</span> <span class="o">:=</span> <span class="nx">svcRegisterDiscovery</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">endpoint</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">5</span> <span class="p">{</span>
                <span class="nx">delEndpoint</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;127.0.0.1:909%d&#34;</span><span class="p">,</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
                <span class="k">for</span> <span class="p">!</span><span class="nx">svcRegisterDiscovery</span><span class="p">.</span><span class="nf">CancelEndpoint</span><span class="p">(</span><span class="nx">delEndpoint</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">delEndpoint</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;127.0.0.1:909%d&#34;</span><span class="p">,</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="k">go</span> <span class="nx">svcRegisterDiscovery</span><span class="p">.</span><span class="nf">ListenLeaseChan</span><span class="p">()</span>
    <span class="k">select</span> <span class="p">{}</span>

<span class="p">}</span>
</code></pre></div><h2 id="八基于-etcd-的共享配置中心实践">八、基于 etcd 的共享配置中心实践</h2>
<p>应用启动的时候拉取某个特定目录下的存储的配置信息，同时注册一个 watcher 并等待更新，etcd 会实时通知应用更新配置</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">etcd</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;context&#34;</span>
    <span class="s">&#34;encoding/json&#34;</span>
    <span class="s">&#34;flag&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;github.com/coreos/etcd/mvcc/mvccpb&#34;</span>
    <span class="s">&#34;log&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">config</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">server</span>
    <span class="nx">database</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">server</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Addr</span>  <span class="kt">string</span> <span class="s">`json:&#34;addr&#34;`</span>
    <span class="nx">Port</span>  <span class="kt">string</span> <span class="s">`json:&#34;port&#34;`</span>
    <span class="nx">Name</span>  <span class="kt">string</span> <span class="s">`json:&#34;app&#34;`</span>
    <span class="nx">Token</span> <span class="kt">string</span> <span class="s">`json:&#34;token&#34;`</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">database</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Type</span>     <span class="kt">string</span> <span class="s">`json:&#34;type&#34;`</span>
    <span class="nx">Url</span>      <span class="kt">string</span> <span class="s">`json:&#34;url&#34;`</span>
    <span class="nx">User</span>     <span class="kt">string</span> <span class="s">`json:&#34;user&#34;`</span>
    <span class="nx">Password</span> <span class="kt">string</span> <span class="s">`json:&#34;password&#34;`</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="p">(</span>
    <span class="c1">// /config/appName/profile
</span><span class="c1"></span>    <span class="nx">configKeyFmt</span> <span class="p">=</span> <span class="s">&#34;/config/%s/%s&#34;</span>
    <span class="nx">Config</span>       <span class="nx">config</span>
    <span class="nx">Env</span>          <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;profile&#34;</span><span class="p">,</span> <span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="s">&#34;use profile for config&#34;</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">configPath</span><span class="p">(</span><span class="nx">appName</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="nx">configKeyFmt</span><span class="p">,</span> <span class="nx">appName</span><span class="p">,</span> <span class="o">*</span><span class="nx">Env</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">InitConfig</span><span class="p">(</span><span class="nx">appName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">path</span> <span class="o">:=</span> <span class="nf">configPath</span><span class="p">(</span><span class="nx">appName</span><span class="p">)</span>
    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">path</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;get config from etcd fail, err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Kvs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Value</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">Config</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;unmarshal config info fail, err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;init config info success...&#34;</span><span class="p">)</span>

    <span class="k">go</span> <span class="nf">watchConfig</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">watchConfig</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">watch</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Watch</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">path</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">w</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">watch</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;w: %v\\\\n&#34;</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Events</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Type</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nx">mvccpb</span><span class="p">.</span><span class="nx">PUT</span><span class="p">:</span>
                <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Kv</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">Config</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                    <span class="nx">log</span><span class="p">.</span><span class="nf">Panicf</span><span class="p">(</span><span class="s">&#34;format err of %s, err: %v&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Kv</span><span class="p">.</span><span class="nx">Value</span><span class="p">),</span> <span class="nx">err</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;update config success...&#34;</span><span class="p">)</span>
            <span class="k">case</span> <span class="nx">mvccpb</span><span class="p">.</span><span class="nx">DELETE</span><span class="p">:</span>
                <span class="nx">log</span><span class="p">.</span><span class="nf">Panicf</span><span class="p">(</span><span class="s">&#34;config info is deleted&#34;</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">etcd</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;context&#34;</span>
    <span class="s">&#34;encoding/json&#34;</span>
    <span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">TestInitConfig</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nf">Clear</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nx">config</span><span class="p">{</span><span class="nx">server</span><span class="p">{</span>
        <span class="nx">Addr</span><span class="p">:</span>  <span class="s">&#34;0.0.0.0&#34;</span><span class="p">,</span>
        <span class="nx">Port</span><span class="p">:</span>  <span class="s">&#34;8080&#34;</span><span class="p">,</span>
        <span class="nx">Name</span><span class="p">:</span>  <span class="s">&#34;test&#34;</span><span class="p">,</span>
        <span class="nx">Token</span><span class="p">:</span> <span class="s">&#34;test&#34;</span><span class="p">,</span>
    <span class="p">},</span> <span class="nx">database</span><span class="p">{</span>
        <span class="nx">Type</span><span class="p">:</span>     <span class="s">&#34;mysql&#34;</span><span class="p">,</span>
        <span class="nx">Url</span><span class="p">:</span>      <span class="s">&#34;mysql://127.0.0.1:3306?test&#34;</span><span class="p">,</span>
        <span class="nx">User</span><span class="p">:</span>     <span class="s">&#34;root&#34;</span><span class="p">,</span>
        <span class="nx">Password</span><span class="p">:</span> <span class="s">&#34;123456&#34;</span><span class="p">,</span>
    <span class="p">}}</span>
    <span class="nx">marshal</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">appName</span> <span class="o">:=</span> <span class="s">&#34;test&#34;</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nf">configPath</span><span class="p">(</span><span class="nx">appName</span><span class="p">),</span> <span class="nb">string</span><span class="p">(</span><span class="nx">marshal</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nf">InitConfig</span><span class="p">(</span><span class="nx">appName</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nf">configPath</span><span class="p">(</span><span class="nx">appName</span><span class="p">),</span> <span class="nb">string</span><span class="p">(</span><span class="nx">marshal</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">select</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><h2 id="九基于-etcd-的分布式通知与协调实践">九、基于 etcd 的分布式通知与协调实践</h2>
<h3 id="1-生命探针检测">1、 生命探针检测</h3>
<p>需要依赖 <code>etcd</code> 的 <code>watch</code>机制和 <code>lease</code>机制，检测系统和被检测系统通过在 <code>etcd</code> 上的某个目录进行关联，从而实现解耦</p>
<p><img src="https://i.loli.net/2021/06/04/xTAZ2OCutDdNYIv.png" alt="https//ilolinet/2021/06/04/xTAZ2OCutDdNYIvpng"></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">etcd</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;context&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;github.com/coreos/etcd/clientv3&#34;</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">pathTemplate</span> <span class="p">=</span> <span class="s">&#34;/test/probe/%s&#34;</span>

<span class="kd">type</span> <span class="nx">probe</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ctx</span>      <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
    <span class="nx">workName</span> <span class="kt">string</span>
    <span class="nx">ttl</span>      <span class="kt">int64</span>
    <span class="nx">leaseId</span>  <span class="nx">clientv3</span><span class="p">.</span><span class="nx">LeaseID</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewProbe</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ttl</span> <span class="kt">int64</span><span class="p">)</span> <span class="o">*</span><span class="nx">probe</span> <span class="p">{</span>
    <span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">probe</span><span class="p">{</span>
        <span class="nx">ctx</span><span class="p">:</span>      <span class="nx">ctx</span><span class="p">,</span>
        <span class="nx">workName</span><span class="p">:</span> <span class="nx">name</span><span class="p">,</span>
        <span class="nx">ttl</span><span class="p">:</span>      <span class="nx">ttl</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="nx">leaseId</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">PutWithLease</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">probePath</span><span class="p">(),</span> <span class="nx">p</span><span class="p">.</span><span class="nf">probePath</span><span class="p">(),</span> <span class="nx">ttl</span><span class="p">)</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">leaseId</span> <span class="p">=</span> <span class="nx">leaseId</span>
    <span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">probe</span><span class="p">)</span> <span class="nf">probePath</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="nx">pathTemplate</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">workName</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">probe</span><span class="p">)</span> <span class="nf">postHealth</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">KeepAliveOnce</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">leaseId</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;keepalive fail, err: %v\\\\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">probe</span><span class="p">)</span> <span class="nf">watchLifeProbe</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">probePath</span><span class="p">())</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s is healthy\\\\n&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">workName</span><span class="p">)</span>
        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">.</span><span class="nf">Nanoseconds</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">ttl</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">}</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s is unhealthy\\\\n&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">workName</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><strong>测试代码</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TestNewProbe</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">probe</span> <span class="o">:=</span> <span class="nf">NewProbe</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">probe</span><span class="p">.</span><span class="nf">watchLifeProbe</span><span class="p">()</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">probe</span><span class="p">.</span><span class="nf">postHealth</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;post health fail, err: &#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="p">}</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;post health success &#34;</span><span class="p">)</span>
            <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="k">select</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><h3 id="2-完成系统调度">2、 完成系统调度</h3>
<p>依赖于 <code>watch</code> 机制，控制台负责特定目录的更新，推送系统监听目录的更新</p>
<p><img src="https://i.loli.net/2021/06/04/HsmdchwnMPGzZkq.png" alt="https//ilolinet/2021/06/04/HsmdchwnMPGzZkqpng"></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">etcd</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;context&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;github.com/coreos/etcd/mvcc/mvccpb&#34;</span>
    <span class="s">&#34;log&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">TaskState</span> <span class="kt">uint8</span>

<span class="kd">const</span> <span class="p">(</span>
    <span class="nx">Scheduled</span> <span class="nx">TaskState</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="nx">Starting</span>
    <span class="nx">Running</span>
    <span class="nx">Finished</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">stateList</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;Scheduled&#34;</span><span class="p">,</span> <span class="s">&#34;Starting&#34;</span><span class="p">,</span> <span class="s">&#34;Running&#34;</span><span class="p">,</span> <span class="s">&#34;Finished&#34;</span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">TaskState</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">stateList</span><span class="p">[</span><span class="nx">t</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ParseTaskState</span><span class="p">(</span><span class="nx">state</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">TaskState</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">stateList</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">state</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">TaskState</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">taskScheduler</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ctx</span>   <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
    <span class="nx">Name</span>  <span class="kt">string</span>    <span class="s">`json:&#34;name&#34;`</span>
    <span class="nx">State</span> <span class="nx">TaskState</span> <span class="s">`json:&#34;state&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewTaskScheduler</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">taskName</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">taskScheduler</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">taskScheduler</span><span class="p">{</span>
        <span class="nx">ctx</span><span class="p">:</span>   <span class="nx">ctx</span><span class="p">,</span>
        <span class="nx">Name</span><span class="p">:</span>  <span class="nx">taskName</span><span class="p">,</span>
        <span class="nx">State</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">taskScheduler</span><span class="p">)</span> <span class="nf">Key</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;/scheduler/task/%s&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">taskScheduler</span><span class="p">)</span> <span class="nf">Notify</span><span class="p">(</span><span class="nx">state</span> <span class="nx">TaskState</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">state</span> <span class="p">&lt;</span> <span class="nx">Scheduled</span> <span class="o">||</span> <span class="nx">state</span> <span class="p">&gt;</span> <span class="nx">Finished</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;error state: %d&#34;</span><span class="p">,</span> <span class="nx">state</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">State</span> <span class="p">=</span> <span class="nx">state</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;console notify task %s to work\\\\n&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Key</span><span class="p">(),</span> <span class="nx">t</span><span class="p">.</span><span class="nx">State</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">taskScheduler</span><span class="p">)</span> <span class="nf">WatchNotify</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">watch</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Watch</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Key</span><span class="p">())</span>
    <span class="k">for</span> <span class="nx">w</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">watch</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Events</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Type</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nx">mvccpb</span><span class="p">.</span><span class="nx">PUT</span><span class="p">:</span>
                <span class="nx">t</span><span class="p">.</span><span class="nf">Work</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Kv</span><span class="p">.</span><span class="nx">Value</span><span class="p">))</span>
            <span class="k">case</span> <span class="nx">mvccpb</span><span class="p">.</span><span class="nx">DELETE</span><span class="p">:</span>
                <span class="nx">t</span><span class="p">.</span><span class="nb">close</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">taskScheduler</span><span class="p">)</span> <span class="nf">Work</span><span class="p">(</span><span class="nx">state</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">State</span> <span class="p">=</span> <span class="nf">ParseTaskState</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span>
    <span class="k">switch</span> <span class="nx">state</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">Scheduled</span><span class="p">.</span><span class="nf">String</span><span class="p">():</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;task %s is scheduled\\\\n&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">Starting</span><span class="p">.</span><span class="nf">String</span><span class="p">():</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;task %s begin  working\\\\n&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">Running</span><span class="p">.</span><span class="nf">String</span><span class="p">():</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;task %s is running\\\\n&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">Finished</span><span class="p">.</span><span class="nf">String</span><span class="p">():</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;task %s finnish working\\\\n&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
        <span class="nf">Del</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Key</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">taskScheduler</span><span class="p">)</span> <span class="nb">close</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">State</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div><p>测试代码</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">etcd</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;context&#34;</span>
    <span class="s">&#34;testing&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">TestTaskScheduler</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
    <span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nf">Clear</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>

    <span class="nx">scheduler</span> <span class="o">:=</span> <span class="nf">NewTaskScheduler</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;taskName&#34;</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">scheduler</span><span class="p">.</span><span class="nf">WatchNotify</span><span class="p">()</span>
    <span class="nx">scheduler</span><span class="p">.</span><span class="nf">Notify</span><span class="p">(</span><span class="nx">Scheduled</span><span class="p">)</span>
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="nx">scheduler</span><span class="p">.</span><span class="nf">Notify</span><span class="p">(</span><span class="nx">Starting</span><span class="p">)</span>
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="nx">scheduler</span><span class="p">.</span><span class="nf">Notify</span><span class="p">(</span><span class="nx">Running</span><span class="p">)</span>
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="nx">scheduler</span><span class="p">.</span><span class="nf">Notify</span><span class="p">(</span><span class="nx">Finished</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="3-完成工作汇报">3、 完成工作汇报</h3>
<p>依赖于 <code>watch</code> 机制，启动子任务时建立一个临时目录，子任务可以通过更新这个临时目录的值来汇报自己的工作进度</p>
<p><img src="https://i.loli.net/2021/06/04/WOoDdEi3GRQsA2p.png" alt="https//ilolinet/2021/06/04/WOoDdEi3GRQsA2ppng"></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">etcd</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;context&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;github.com/coreos/etcd/mvcc/mvccpb&#34;</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;strconv&#34;</span>
    <span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">workReporter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ctx</span>      <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span> <span class="s">`json:&#34;ctx&#34;`</span>
    <span class="nx">Name</span>     <span class="kt">string</span>          <span class="s">`json:&#34;name&#34;`</span>
    <span class="nx">progress</span> <span class="kt">int</span>             <span class="s">`json:&#34;progress&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewWorkReporter</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">workReporter</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">workReporter</span><span class="p">{</span>
        <span class="nx">ctx</span><span class="p">:</span>      <span class="nx">ctx</span><span class="p">,</span>
        <span class="nx">Name</span><span class="p">:</span>     <span class="nx">name</span><span class="p">,</span>
        <span class="nx">progress</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">workReporter</span><span class="p">)</span> <span class="nf">Key</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;/work/%s&#34;</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">workReporter</span><span class="p">)</span> <span class="nf">FmtProgress</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">progress</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;%&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">workReporter</span><span class="p">)</span> <span class="nf">ParseProgress</span><span class="p">(</span><span class="nx">progress</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nf">HasSuffix</span><span class="p">(</span><span class="nx">progress</span><span class="p">,</span> <span class="s">&#34;%&#34;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;progress isn&#39;t end of %&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">parse</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">progress</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nx">progress</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="nx">parse</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">workReporter</span><span class="p">)</span> <span class="nf">Report</span><span class="p">(</span><span class="nx">progress</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">progress</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">progress</span> <span class="p">&gt;</span> <span class="mi">100</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;the progress of %s is error&#34;</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">w</span><span class="p">.</span><span class="nx">progress</span> <span class="p">=</span> <span class="nx">progress</span>
    <span class="k">return</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Key</span><span class="p">(),</span> <span class="nx">w</span><span class="p">.</span><span class="nf">FmtProgress</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">workReporter</span><span class="p">)</span> <span class="nf">WatchNotify</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">watchChan</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Watch</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Key</span><span class="p">())</span>
    <span class="k">for</span> <span class="nx">watch</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">watchChan</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">watch</span><span class="p">.</span><span class="nx">Events</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Type</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nx">mvccpb</span><span class="p">.</span><span class="nx">PUT</span><span class="p">:</span>
                <span class="nx">progress</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Kv</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
                <span class="nx">parseInt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">ParseProgress</span><span class="p">(</span><span class="nx">progress</span><span class="p">)</span>
                <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                    <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;parseInt paogress of %s fail, progress: %s\\\\n&#34;</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">progress</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="p">}</span>
                <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;the paogress of %s is %s\\\\n&#34;</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">progress</span><span class="p">)</span>
                <span class="nx">w</span><span class="p">.</span><span class="nx">progress</span> <span class="p">=</span> <span class="nx">parseInt</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>测试代码</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">etcd</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;context&#34;</span>
    <span class="s">&#34;math/rand&#34;</span>
    <span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">TestWorkReporter</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
    <span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nf">Clear</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="nx">reporter</span> <span class="o">:=</span> <span class="nf">NewWorkReporter</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;workReporter&#34;</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">reporter</span><span class="p">.</span><span class="nf">WatchNotify</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="p">{</span>
        <span class="nx">i</span> <span class="o">+=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">100</span> <span class="p">{</span>
            <span class="nx">i</span> <span class="p">=</span> <span class="mi">100</span>
        <span class="p">}</span>
        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">reporter</span><span class="p">.</span><span class="nf">Report</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;err: %v\\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Zookeeper学习笔记</title>
			<link>https://whocanfly.gitee.io/posts/zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
			<pubDate>Sun, 20 Dec 2020 17:54:51 +0800</pubDate>
			
			<guid>https://whocanfly.gitee.io/posts/zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
			<description>zookeeper 的 ACL 权限控制 ​ ACL 权限控制，使用 scheme : id : permission 来标识，主要涵盖三个方面： 权限模式：授权的策略 授权对象：授权对象 权限：授予的权限 其特性如下： zookeeper 的权</description>
			<content type="html"><![CDATA[<h2 id="zookeeper-的-acl-权限控制">zookeeper 的 ACL 权限控制</h2>
<p>​       ACL 权限控制，使用 scheme : id : permission 来标识，主要涵盖三个方面：</p>
<ul>
<li>
<p>权限模式：授权的策略</p>
</li>
<li>
<p>授权对象：授权对象</p>
</li>
<li>
<p>权限：授予的权限</p>
<p>其特性如下：</p>
</li>
<li>
<p>zookeeper 的权限控制是基于每个znode节点的，需要对每个结点设置权限</p>
</li>
<li>
<p>每个znode支持设置多种权限方案和多个权限</p>
</li>
<li>
<p>子节点不会继承父节点的权限，客户端无权访问某节点，但可能可以访问它的子节点</p>
</li>
</ul>
<p>e.g.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">setAcl /test2 ip:192.168.60.130:crwda 
</code></pre></div><h3 id="权限模式">权限模式</h3>
<p>​          采用何种方式授权</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>world</td>
<td>只有一个用户：anyone，代表登录zookeeper所以人（）</td>
</tr>
<tr>
<td>ip</td>
<td>对客户端使用IP地址认证</td>
</tr>
<tr>
<td>auth</td>
<td>使用已添加的用户认证</td>
</tr>
<tr>
<td>digest</td>
<td>使用 ”用户名：密码“ 方式认证</td>
</tr>
</tbody>
</table>
<h3 id="授权对象">授权对象</h3>
<p>​	给谁授予权限</p>
<p>​	授权对象ID是指，权限赋予的实体，例如：IP地址或用户</p>
<h3 id="授予的权限">授予的权限</h3>
<p>​	授予什么权限</p>
<p>​	可以授予的权限包括 create、delete、read、write、admin 也就是增、删、改、查、管理权限，这5种权限简写为cdrwa，注意这5种权限中，delete是指对子节点的删除权限、其他四种指对自身的操作权限</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>ACL 简写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>create</td>
<td>c</td>
<td>可以创建子节点</td>
</tr>
<tr>
<td>delete</td>
<td>d</td>
<td>可以删除子节点</td>
</tr>
<tr>
<td>read</td>
<td>r</td>
<td>可以读取节点数据及显示子节点列表</td>
</tr>
<tr>
<td>write</td>
<td>w</td>
<td>可以设置节点数据</td>
</tr>
<tr>
<td>admin</td>
<td>a</td>
<td>可以设置节点访问控制列表权限</td>
</tr>
</tbody>
</table>
<h3 id="授权的相关命令">授权的相关命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>使用方式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>getAcl</td>
<td>getAcl<!-- raw HTML omitted --></td>
<td>读取ACL.权限</td>
</tr>
<tr>
<td>setAcl</td>
<td>setAcl<!-- raw HTML omitted --><!-- raw HTML omitted --></td>
<td>设置ACL权限</td>
</tr>
<tr>
<td>addauth</td>
<td>addauth<!-- raw HTML omitted --><!-- raw HTML omitted --></td>
<td>添加认证用户</td>
</tr>
</tbody>
</table>
<h3 id="案例">案例</h3>
<ul>
<li>
<p>world 授权模式</p>
<p>命令</p>
<pre><code class="language-shel" data-lang="shel">setAcl &lt;apth&gt; world:anyone:&lt;acl&gt;
</code></pre></li>
<li>
<p>IP 授权模式</p>
<p>命令</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">setAcl &lt;path&gt; ip:&lt;ip&gt;:&lt;acl&gt;
</code></pre></div></li>
<li>
<p>auth 授权模式</p>
<p>命令</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">addauth digest &lt;user&gt;:&lt;password&gt; <span class="c1"># 添加认证用户</span>
setAcl &lt;path&gt; auth:&lt;user&gt;:&lt;acl&gt;
</code></pre></div><p>e.g.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>zk: 172.17.0.4:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 1<span class="o">]</span> create /node <span class="s2">&#34;node&#34;</span>
Created /node
<span class="o">[</span>zk: 172.17.0.4:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 2<span class="o">]</span> getAcl /node
<span class="s1">&#39;world,&#39;</span>anyone
: cdrwa
<span class="o">[</span>zk: 172.17.0.4:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 3<span class="o">]</span> setAcl /node auth:wuyi:adra
Acl is not valid : /node
<span class="o">[</span>zk: 172.17.0.4:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 4<span class="o">]</span> addauth digest wuyi:123456
<span class="o">[</span>zk: 172.17.0.4:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 5<span class="o">]</span> setAcl /node auth:wuyi:adra
<span class="o">[</span>zk: 172.17.0.4:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 6<span class="o">]</span> getAcl /node
<span class="s1">&#39;digest,&#39;</span>wuyi:dXM1WQjCmiOQtOD8PAQtDp5fCpY<span class="o">=</span>
: dra
<span class="o">[</span>zk: 172.17.0.4:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 7<span class="o">]</span> 
</code></pre></div></li>
<li>
<p>digest 授权模式：</p>
<p>命令</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">setAcl &lt;path&gt; digest:&lt;user&gt;:&lt;password&gt;:&lt;acl&gt;
</code></pre></div><p>这里的密码是经过 SHA1及 base64 处理的密文，在 shell 中可以通过一下命令计算：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">echo</span> -n &lt;user&gt;:&lt;password&gt; <span class="p">|</span> openssl dgst -binary -sha1 <span class="p">|</span> openssl base64
</code></pre></div><p>e.g.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@centos7 ~<span class="o">]</span><span class="c1"># echo -n wuyi:123456 | openssl dgst -binary -sha1 | openssl base64</span>
<span class="nv">dXM1WQjCmiOQtOD8PAQtDp5fCpY</span><span class="o">=</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>zk: 172.17.0.4:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 1<span class="o">]</span> create /node <span class="s2">&#34;node&#34;</span>
Created /node
<span class="o">[</span>zk: 172.17.0.4:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 2<span class="o">]</span> setAcl /node digest:wuyi:dXM1WQjCmiOQtOD8PAQtDp5fCpY<span class="o">=</span>:cdrwa
<span class="o">[</span>zk: 172.17.0.4:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 3<span class="o">]</span> getAcl /node
Authentication is not valid : /node
<span class="o">[</span>zk: 172.17.0.4:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 4<span class="o">]</span> addauth digest wuyi:123456
<span class="o">[</span>zk: 172.17.0.4:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 5<span class="o">]</span> getAcl /node
<span class="s1">&#39;digest,&#39;</span>wuyi:dXM1WQjCmiOQtOD8PAQtDp5fCpY<span class="o">=</span>
: cdrwa
<span class="o">[</span>zk: 172.17.0.4:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 6<span class="o">]</span> 
</code></pre></div><h3 id="acl-超级管理员">ACL 超级管理员</h3>
<p>​	zookeeper  的权限管理模式有一种叫做 super，该模式提供一个超管可以方便的访问任何权限的节点，假设这个超管是 super:admin，需要先为超管生成密码的密文</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">echo</span> -n super:admin <span class="p">|</span> openssl dgst -binary -sha1 <span class="p">|</span> openssl base64
</code></pre></div><p>​	在 zookeeper 目录 /bin/zkServer.sh 中添加如下代码</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="s2">&#34;Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs=&#34;</span> <span class="se">\
</span></code></pre></div><p>添加之后为</p>
<p><img src="https://s2.loli.net/2022/04/10/E64NWqnwzLbTrRP.png" alt="image-20200831101424059"></p>
<p>重启 zookeeper 之后</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">addauth digest super:admin <span class="c1"># 添加认证用用户</span>
</code></pre></div></li>
</ul>
]]></content>
		</item>
		
	</channel>
</rss>
